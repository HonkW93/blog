{"meta":{"title":"HonkW","subtitle":"IC Learner","description":"言之命至，人随己愿<br>功不唐捐，自有因果","author":"HonkW","url":"https://blog.honk.wang","root":"/"},"pages":[{"title":"说说","date":"2020-07-15T14:10:38.000Z","updated":"2024-07-14T02:35:34.385Z","comments":false,"path":"artitalk/index.html","permalink":"https://blog.honk.wang/artitalk/index.html","excerpt":"","text":""},{"title":"关于我","date":"2020-02-29T14:17:11.000Z","updated":"2024-07-13T16:38:04.632Z","comments":false,"path":"about/index.html","permalink":"https://blog.honk.wang/about/index.html","excerpt":"","text":"言之命至，人随己愿 —— 刘在石 功不唐捐，自有因果 📜 关于我 1234567891011121314module introduction( input [39:0] Name , //HonkW 48 6F 6E 6B 57 input [7:0] Age , //26 input Gender , //Male input [13*8-1:0] Address , //Sichuan,China input [29*8-1:0] Github , //https://github.com/honkw93 output [1:0] Motion ); localparam Happy = 2&#x27;d0; localparam Sad = 2&#x27;d1; localparam Indifferent = 2&#x27;d2; assign Motion = Happy; ✉️ 联系我 请发邮件📧或在留言板留言 ⚠️免责声明 本站以分享互联网经验、学习知识为目的，所有文章所涉及使用的工具、资源等均来自互联网， 仅供学习和研究使用，版权归作者所有。本站内的文章多为博主原创，仅供学习交流之用，不参与商业用途。 如果无意之中侵犯了您的版权，请来信告知。本站将在第一时间删除！ 遵守相关法律法规，由于本站资源部分来源于网络，开发也是使用开源模板，故无法核实资源侵权的真实性，无论出于何种目的要求本站删除内容，需要提供相关证明，否则不予处理。"},{"title":"分类","date":"2020-02-29T14:17:03.000Z","updated":"2024-07-13T15:48:14.835Z","comments":false,"path":"categories/index.html","permalink":"https://blog.honk.wang/categories/index.html","excerpt":"","text":""},{"title":"工具箱","date":"2020-08-22T11:01:07.000Z","updated":"2024-07-14T08:59:51.292Z","comments":true,"path":"box/index.html","permalink":"https://blog.honk.wang/box/index.html","excerpt":"","text":"个人用工具盒子。访客请勿滥用。 导航 个人制作的一些导航网站。外链Storage站。 导航网站 个人网址导航 IC公众号导航 IC公众号-文章爬取 北美吐槽君-文章爬取 CloudFlare&amp;SCF CloudFlare Workers以及腾讯云SCF实现的一些功能。 网盘 OneDrive天翼云GoogleDriveOneManager-phponedrive-cf-indexOneManager-php，An index &amp; manager of Onedrive based on serverless. qkqpttgf/OneManager-php: An index &amp; manager of Onedrive based on serverless. Can be deployed to Heroku/Glitch/SCF/FG/FC/CFC/PHP web hosting/VPS. 选择Deploy to Tencent Serverless Cloud Function (SCF 腾讯无服务器云函数)onedrive-cf-index，OneDrive网盘目录 onedrive-cf-index: 🏵 Probably the best looking OneDrive Index around! Powered by Cloudflare Workers.PanIndex，天翼云网盘目录 libsgh/PanIndex: 网盘目录直链，目前支持天翼云 天翼云网盘还有另外几种部署方法，但现在都已各自不再授权，逐渐失效。 CTlist天翼云盘的直链解析程序TCshareCTList：一个可以绑定多个天翼云网盘的目录列表程序，支持视频播放 - Rat’s Blog iiiiiii1/CTList: Sample list for CTCloud. CTList: Sample list for CTCloud.【调用天翼云盘成网站】天翼云盘直链平台 支持多账号，支持永久直链，支持分享任意目录（列目录） - 『原创发布区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn 再给大家带来一款天翼云盘的直链解析程序~ - 子翔的小窝 又一款天翼云盘直链平台 支持多账号，支持永久直链，支持分享任意目录（列目录）|替代CTlist绝佳方案 - 天下无鱼【Notes/经验】腾讯云SCF云函数搭建TCShare文件目录详细教程 - MoeBlog 免费部署 150 元 / 年的天翼云盘直链解析系统 - LOGI 使用腾讯云函数SCF搭建TCShare – 夜半观星GoIndexGDIndexGoIndex，支持在线预览，播放等功能的Google Drive网盘。（已挂） Github：Aicirou/goindex-theme-acrou: This is a goindex theme.一个goindex的扩展主题。GDIndex，使用Vue编写的 Google Drive 目录。 Github：GDIndex: A Google Drive Index built with Vue Running on CloudFlare Workers 科学 需要不断更换域名。(已挂) 万能的CLOUDFLARE WORKERS+JSProxy代理？！ EtherDream/jsproxy: 一个基于浏览器端 JS 实现的在线代理 netptop/siteproxy: reverse proxy, 反向代理,免翻墙访问Youtube/twitter/Google, 支持telegram web登录。请勿将本项目用于非法用途，否则后果自负。 页游 有意思的网页游戏。 页游 Vim-AdventuresGit-BranchingBash一起玩VIM Adventures学习Vim吧！一起Learn Git Branching学习Git吧！一起解决A command-line murder mystery谋杀案学习Bash吧！ 一起玩Wargames学习Bash吧！ 一起玩进入Terminus学习Bash吧！ 2048魔方吃豆人打砖块坦克大战2048，风靡一时的小游戏Cuber，可以随便转的网页虚拟魔方Pacman，吃豆人，儿时回忆Dx-Ball，打砖块，儿时回忆Battle-City，坦克大战，儿时回忆 服务器 谷歌 谷歌云、阿里云配置"},{"title":"Love","date":"2020-06-04T14:42:42.000Z","updated":"2024-07-13T16:29:47.361Z","comments":true,"path":"love/index.html","permalink":"https://blog.honk.wang/love/index.html","excerpt":"","text":"JaneR♥HonkW 相恋： function setTime() { var create_time = Math.round(new Date(Date.UTC(2019, 2, 15, 19, 0, 0)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = currentTime[0] + ' 年 ' + currentTime[1] + ' 天 ' + currentTime[2] + ' 时 ' + currentTime[3] + ' 分 ' + currentTime[4] + ' 秒 '; document.getElementById(\"htmer_time\").innerHTML = currentTimeHtml; } function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second >= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second >= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second >= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second >= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second > 0) { time[4] = second; } return time; } setInterval(setTime, 1000); ❤️ 历程 现在… 2024年3月23日，J.P. 2023年1月15日，结婚 2022年8月6日，领证 2022年3月15日，3年 2021年10月2日，1000天 2021年8月9日，高温假期，问道青城 2021年7月19日，一年生日，尝酸菜鱼 2021年5月22日，求婚 2021年5月20日，0520，海底捞捞 2021年5月1日，YTJT，川西旅行 2021年3月15日，简简单单，周年快乐 2021年2月20日，长途跋涉，重庆见姐 2021年2月10日，两边老家，各见亲友 2020年12月25日，北京学习，暂别两地 2020年10月1日，万州之行，岳父岳母 2020年8月30日，见见家长，周深专辑 2020年8月6日，夏日旅行，毕棚沟里 2020年7月30日，农历公历，同天生日~ 2020年6月15日，—❥ 2020年6月13日，北京来客，Space 2020年5月20日，节日纪念，好利来 2020年3月15日，周年纪念，未能见面 2019年8月4日，云南旅行，Double Date 2019年4月16日，百天纪念，旋转木马 2019年3月15日，相恋 💕 2019年1月7日，相识"},{"title":"Music","date":"2020-07-13T13:20:51.000Z","updated":"2024-07-14T02:33:57.840Z","comments":true,"path":"music/index.html","permalink":"https://blog.honk.wang/music/index.html","excerpt":"","text":"网易云音乐歌单 qq音乐歌单"},{"title":"留言板","date":"2020-03-13T11:42:37.000Z","updated":"2024-07-13T16:31:54.731Z","comments":true,"path":"messages/index.html","permalink":"https://blog.honk.wang/messages/index.html","excerpt":"","text":"留留言 聊聊天 留言须知 建议留下昵称与邮箱（QQ最佳，可收到邮件回复），方便及时收到博主回复。 请勿恶意评论。 请勿评论违法内容。"},{"title":"友情链接","date":"2020-05-01T08:34:47.000Z","updated":"2024-07-14T02:32:26.856Z","comments":true,"path":"link/index.html","permalink":"https://blog.honk.wang/link/index.html","excerpt":"","text":"IC相关从业者。本博客搭建感谢各位大佬无私分享。友链的彩灯根据各个博客首页风格选取，博主若不满意可留言变更。 ✉️ 联系我 请发邮件📧或在留言板留言 ⚠️免责声明 本站以分享互联网经验、学习知识为目的，所有文章所涉及使用的工具、资源等均来自互联网， 仅供学习和研究使用，版权归作者所有。本站内的文章多为博主原创，仅供学习交流之用，不参与商业用途。 如果无意之中侵犯了您的版权，请来信告知。本站将在第一时间删除！ 遵守相关法律法规，由于本站资源部分来源于网络，开发也是使用开源模板，故无法核实资源侵权的真实性，无论出于何种目的要求本站删除内容，需要提供相关证明，否则不予处理。 ℹ️我的Blog资料 Blog name: HonkW Blog link: https://honk.wang Blog avatar: https://cdn-1301954091.cos.ap-chengdu.myqcloud.com/blog/background/avatar.jpg Blog description: 言之命至，人随己愿"},{"title":"零零碎碎的记录","date":"2020-04-26T15:38:21.000Z","updated":"2024-07-14T03:37:38.190Z","comments":false,"path":"photo/index.html","permalink":"https://blog.honk.wang/photo/index.html","excerpt":"","text":"生活 零零碎碎 韩孝周 关于韩孝周"},{"title":"Sponsor","date":"2022-03-26T12:03:49.000Z","updated":"2022-12-30T14:41:59.865Z","comments":true,"path":"sponsor/index.html","permalink":"https://blog.honk.wang/sponsor/index.html","excerpt":"","text":"感谢以下朋友的支持和捐助~ 感谢j*e微信捐助￥66.6 感谢*戏微信捐助￥100 感谢S*i微信捐助￥100 感谢*帅微信捐助￥52 感谢S*S微信捐助￥88.88 感谢xxxxxx微信捐助￥8.88 感谢*子微信捐助￥1 感谢*原微信捐助￥10 感谢*渡微信捐助￥66.66 感谢*唱微信捐助￥2 感谢*光微信捐助￥10 感谢J*g微信捐助￥5 感谢*甘微信捐助￥10 感谢*l微信捐助￥10 当前累计捐助：531.02"},{"title":"文章统计","date":"2020-05-14T16:49:31.000Z","updated":"2024-07-13T16:34:18.017Z","comments":false,"path":"statistics/index.html","permalink":"https://blog.honk.wang/statistics/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-16T14:08:52.708Z","updated":"2024-07-16T14:08:52.708Z","comments":true,"path":"styles/fish.js","permalink":"https://blog.honk.wang/styles/fish.js","excerpt":"","text":"var RENDERER = { POINT_INTERVAL : 5, FISH_COUNT : 3, MAX_INTERVAL_COUNT : 50, INIT_HEIGHT_RATE : 0.5, THRESHOLD : 50, init : function(){ this.setParameters(); this.reconstructMethods(); this.setup(); this.bindEvent(); this.render(); }, setParameters : function(){ this.$window = $(window); this.$container = $('#jsi-flying-fish-container'); this.$canvas = $(''); this.context = this.$canvas.appendTo(this.$container).get(0).getContext('2d'); this.points = []; this.fishes = []; this.watchIds = []; }, createSurfacePoints : function(){ var count = Math.round(this.width / this.POINT_INTERVAL); this.pointInterval = this.width / (count - 1); this.points.push(new SURFACE_POINT(this, 0)); for(var i = 1; i < count; i++){ var point = new SURFACE_POINT(this, i * this.pointInterval), previous = this.points[i - 1]; point.setPreviousPoint(previous); previous.setNextPoint(point); this.points.push(point); } }, reconstructMethods : function(){ this.watchWindowSize = this.watchWindowSize.bind(this); this.jdugeToStopResize = this.jdugeToStopResize.bind(this); this.startEpicenter = this.startEpicenter.bind(this); this.moveEpicenter = this.moveEpicenter.bind(this); this.reverseVertical = this.reverseVertical.bind(this); this.render = this.render.bind(this); }, setup : function(){ this.points.length = 0; this.fishes.length = 0; this.watchIds.length = 0; this.intervalCount = this.MAX_INTERVAL_COUNT; this.width = this.$container.width(); this.height = this.$container.height(); this.fishCount = this.FISH_COUNT * this.width / 500 * this.height / 500; this.$canvas.attr({width : this.width, height : this.height}); this.reverse = false; this.fishes.push(new FISH(this)); this.createSurfacePoints(); }, watchWindowSize : function(){ this.clearTimer(); this.tmpWidth = this.$window.width(); this.tmpHeight = this.$window.height(); this.watchIds.push(setTimeout(this.jdugeToStopResize, this.WATCH_INTERVAL)); }, clearTimer : function(){ while(this.watchIds.length > 0){ clearTimeout(this.watchIds.pop()); } }, jdugeToStopResize : function(){ var width = this.$window.width(), height = this.$window.height(), stopped = (width == this.tmpWidth && height == this.tmpHeight); this.tmpWidth = width; this.tmpHeight = height; if(stopped){ this.setup(); } }, bindEvent : function(){ this.$window.on('resize', this.watchWindowSize); this.$container.on('mouseenter', this.startEpicenter); this.$container.on('mousemove', this.moveEpicenter); this.$container.on('click', this.reverseVertical); }, getAxis : function(event){ var offset = this.$container.offset(); return { x : event.clientX - offset.left + this.$window.scrollLeft(), y : event.clientY - offset.top + this.$window.scrollTop() }; }, startEpicenter : function(event){ this.axis = this.getAxis(event); }, moveEpicenter : function(event){ var axis = this.getAxis(event); if(!this.axis){ this.axis = axis; } this.generateEpicenter(axis.x, axis.y, axis.y - this.axis.y); this.axis = axis; }, generateEpicenter : function(x, y, velocity){ if(y < this.height / 2 - this.THRESHOLD || y > this.height / 2 + this.THRESHOLD){ return; } var index = Math.round(x / this.pointInterval); if(index < 0 || index >= this.points.length){ return; } this.points[index].interfere(y, velocity); }, reverseVertical : function(){ this.reverse = !this.reverse; for(var i = 0, count = this.fishes.length; i < count; i++){ this.fishes[i].reverseVertical(); } }, controlStatus : function(){ for(var i = 0, count = this.points.length; i < count; i++){ this.points[i].updateSelf(); } for(var i = 0, count = this.points.length; i < count; i++){ this.points[i].updateNeighbors(); } if(this.fishes.length < this.fishCount){ if(--this.intervalCount == 0){ this.intervalCount = this.MAX_INTERVAL_COUNT; this.fishes.push(new FISH(this)); } } }, render : function(){ requestAnimationFrame(this.render); this.controlStatus(); this.context.clearRect(0, 0, this.width, this.height); this.context.fillStyle = 'hsl(180,100%,96.3%)'; for(var i = 0, count = this.fishes.length; i < count; i++){ this.fishes[i].render(this.context); } this.context.save(); this.context.globalCompositeOperation = 'xor'; this.context.beginPath(); this.context.moveTo(0, this.reverse ? 0 : this.height); for(var i = 0, count = this.points.length; i < count; i++){ this.points[i].render(this.context); } this.context.lineTo(this.width, this.reverse ? 0 : this.height); this.context.closePath(); this.context.fill(); this.context.restore(); } }; var SURFACE_POINT = function(renderer, x){ this.renderer = renderer; this.x = x; this.init(); }; SURFACE_POINT.prototype = { SPRING_CONSTANT : 0.03, SPRING_FRICTION : 0.9, WAVE_SPREAD : 0.3, ACCELARATION_RATE : 0.01, init : function(){ this.initHeight = this.renderer.height * this.renderer.INIT_HEIGHT_RATE; this.height = this.initHeight; this.fy = 0; this.force = {previous : 0, next : 0}; }, setPreviousPoint : function(previous){ this.previous = previous; }, setNextPoint : function(next){ this.next = next; }, interfere : function(y, velocity){ this.fy = this.renderer.height * this.ACCELARATION_RATE * ((this.renderer.height - this.height - y) >= 0 ? -1 : 1) * Math.abs(velocity); }, updateSelf : function(){ this.fy += this.SPRING_CONSTANT * (this.initHeight - this.height); this.fy *= this.SPRING_FRICTION; this.height += this.fy; }, updateNeighbors : function(){ if(this.previous){ this.force.previous = this.WAVE_SPREAD * (this.height - this.previous.height); } if(this.next){ this.force.next = this.WAVE_SPREAD * (this.height - this.next.height); } }, render : function(context){ if(this.previous){ this.previous.height += this.force.previous; this.previous.fy += this.force.previous; } if(this.next){ this.next.height += this.force.next; this.next.fy += this.force.next; } context.lineTo(this.x, this.renderer.height - this.height); } }; var FISH = function(renderer){ this.renderer = renderer; this.init(); }; FISH.prototype = { GRAVITY : 0.4, init : function(){ this.direction = Math.random() < 0.5; this.x = this.direction ? (this.renderer.width + this.renderer.THRESHOLD) : -this.renderer.THRESHOLD; this.previousY = this.y; this.vx = this.getRandomValue(4, 10) * (this.direction ? -1 : 1); if(this.renderer.reverse){ this.y = this.getRandomValue(this.renderer.height * 1 / 10, this.renderer.height * 4 / 10); this.vy = this.getRandomValue(2, 5); this.ay = this.getRandomValue(0.05, 0.2); }else{ this.y = this.getRandomValue(this.renderer.height * 6 / 10, this.renderer.height * 9 / 10); this.vy = this.getRandomValue(-5, -2); this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; this.theta = 0; this.phi = 0; }, getRandomValue : function(min, max){ return min + (max - min) * Math.random(); }, reverseVertical : function(){ this.isOut = !this.isOut; this.ay *= -1; }, controlStatus : function(context){ this.previousY = this.y; this.x += this.vx; this.y += this.vy; this.vy += this.ay; if(this.renderer.reverse){ if(this.y > this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy -= this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(0.05, 0.2); } this.isOut = false; } }else{ if(this.y < this.renderer.height * this.renderer.INIT_HEIGHT_RATE){ this.vy += this.GRAVITY; this.isOut = true; }else{ if(this.isOut){ this.ay = this.getRandomValue(-0.2, -0.05); } this.isOut = false; } } if(!this.isOut){ this.theta += Math.PI / 20; this.theta %= Math.PI * 2; this.phi += Math.PI / 30; this.phi %= Math.PI * 2; } this.renderer.generateEpicenter(this.x + (this.direction ? -1 : 1) * this.renderer.THRESHOLD, this.y, this.y - this.previousY); if(this.vx > 0 && this.x > this.renderer.width + this.renderer.THRESHOLD || this.vx < 0 && this.x < -this.renderer.THRESHOLD){ this.init(); } }, render : function(context){ context.save(); context.translate(this.x, this.y); context.rotate(Math.PI + Math.atan2(this.vy, this.vx)); context.scale(1, this.direction ? 1 : -1); context.beginPath(); context.moveTo(-30, 0); context.bezierCurveTo(-20, 15, 15, 10, 40, 0); context.bezierCurveTo(15, -10, -20, -15, -30, 0); context.fill(); context.save(); context.translate(40, 0); context.scale(0.9 + 0.2 * Math.sin(this.theta), 1); context.beginPath(); context.moveTo(0, 0); context.quadraticCurveTo(5, 10, 20, 8); context.quadraticCurveTo(12, 5, 10, 0); context.quadraticCurveTo(12, -5, 20, -8); context.quadraticCurveTo(5, -10, 0, 0); context.fill(); context.restore(); context.save(); context.translate(-3, 0); context.rotate((Math.PI / 3 + Math.PI / 10 * Math.sin(this.phi)) * (this.renderer.reverse ? -1 : 1)); context.beginPath(); if(this.renderer.reverse){ context.moveTo(5, 0); context.bezierCurveTo(10, 10, 10, 30, 0, 40); context.bezierCurveTo(-12, 25, -8, 10, 0, 0); }else{ context.moveTo(-5, 0); context.bezierCurveTo(-10, -10, -10, -30, 0, -40); context.bezierCurveTo(12, -25, 8, -10, 0, 0); } context.closePath(); context.fill(); context.restore(); context.restore(); this.controlStatus(context); } }; $(function(){ RENDERER.init(); });"},{"title":"标签","date":"2020-02-29T14:17:11.000Z","updated":"2024-07-13T16:11:53.378Z","comments":false,"path":"tags/index.html","permalink":"https://blog.honk.wang/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-16T14:17:29.078Z","updated":"2024-07-16T14:17:29.078Z","comments":true,"path":"styles/fish-func.js","permalink":"https://blog.honk.wang/styles/fish-func.js","excerpt":"","text":"// 页脚养鱼 fish(); function fish() { return ( $(\"#footer-wrap\").css({ position: \"absolute\", \"text-align\": \"center\", top: 0, right: 0, left: 0, bottom: 0, }), $(\"footer\").append( '' ), $(\"body\").append( '' ), this ); }"},{"title":"韩孝珠","date":"2020-04-26T15:38:21.000Z","updated":"2024-07-14T03:38:53.538Z","comments":false,"path":"photo/hyo/index.html","permalink":"https://blog.honk.wang/photo/hyo/index.html","excerpt":"","text":"最新综艺《首尔乡巴佬》，首尔出身的明星们去嘉宾的故乡，体验那里的生活的真人秀综艺 Running Man，一共上过两次，共四集 两天一夜cut"},{"title":"生活","date":"2020-04-26T15:38:21.000Z","updated":"2024-07-14T03:39:49.793Z","comments":false,"path":"photo/life/index.html","permalink":"https://blog.honk.wang/photo/life/index.html","excerpt":"","text":""}],"posts":[{"title":"8b10b","slug":"ic/design/8b10b","date":"2024-07-28T11:07:06.000Z","updated":"2024-08-26T15:52:24.984Z","comments":true,"path":"posts/8b10b/","link":"","permalink":"https://blog.honk.wang/posts/8b10b/","excerpt":"","text":"背景 关于为什么要进行8b10b编码，主要是为了直流平衡（dc balance），由于交流耦合会导致信号抖动、ISI等问题。可以参考8B/10B编码基本原理。 本文基于IBM的8b10b编解码的原文章A DC-Balanced, Partitioned-Block, 8B/10B Transmission Code | IBM Journals &amp; Magazine | IEEE Xplore。 8b10b编码分为5b6b和3b4b两个部分，其编码逻辑如下图所示： 一般材料会采用5b6b和3b4b如下的两个编码表，但却没有说明EDCBA到abcdei的命名方式，以及原本编码的具体逻辑。 数据码 5b6b D.x.y中的.x代表8b数据中5b的部分，比如D.13.y就是5'b01101。 5b6b的编码逻辑： 将5b数据EDCBA倒为ABCDE，最后一位I统一补0，形成ABCDEI 观察ABCDEI的0，1数量是否平衡， 0，1平衡（各3个），直接输出abcdei=ABCDEI 0，1不平衡，根据码表进行比特位翻转 码表无标红比特位，直接输出abcdei=ABCDEI 码表有标红比特位，翻转对应比特位 举例： D.11.y：EDCBA=01011，倒转补0后ABCDEI=110100，0，1平衡，不需要翻转码字，abcdei=ABCDEI=110100 D.18.y：EDCBA=10010，倒转补0后ABCDEI=010010，0，1不平衡，根据码表翻转码字I，abcdei=ABCDEI'=010011 D.24.y：EDCBA=11000，倒转补0后ABCDEI=000110，0，1不平衡，根据码表翻转码字C和E，abcdei=ABC'DE'I=001100 D.30.y：EDCBA=11110，倒转补0后ABCDEI=011110，0，1不平衡，根据码表，不需要翻转码字，abcdei=ABCDEI=011110 D.31.y：EDCBA=11111，倒转补0后ABCDEI=111110，0，1不平衡，根据码表翻转码字B、D和I，abcdei=AB'CD'EI'=101011 3b4b D.x.y代表中的.y代表8b数据中3b的部分，比如D.x.4就是3'b100。 3b4b的编码逻辑： 将3b数据HGF倒为FGH，最后一位J统一补0，形成FGHJ 观察FGHJ的0，1数量是否平衡， 0，1平衡（各2个），直接输出fghj=FGHJ 0，1不平衡，根据码表进行比特位翻转 码表无标红比特位，直接输出fghj=FGHJ 码表有标红比特位，翻转对应比特位 举例： D.x.3：HGF=011，翻转补0后FGHJ=1100，0，1平衡，不需要翻转码字，fghj=FGHJ=1100 D.x.1：HGF=001，翻转补0后FGHJ=1000，0，1不平衡，根据码表翻转码字J，fghj=FGHJ'=1001 D.x.4：HGF=100，翻转补0后FGHJ=0010，0，1不平衡，根据码表，不需要翻转码字，fghj=FGHJ=0010 D.x.7： D.x.P07：HGF=111，翻转补0后FGHJ=1110，0，1不平衡，根据码表，不需要翻转码字，fghj=FGHJ=1110 若D.x.P07有码流不平衡风险，则使用D.x.A07（Alternative，备用码）根据码表翻转码字F和J，fghj=F'GHJ'=0111 关于D.x.P07和D.x.A07，后续章节会详细讲解。 数据极性 不论是5b6b编码，还是3b4b编码，其编码均有属性叫做极性（disparity），极性代表这个码字0和1的数量多少。 5b6b举例： D.24.y，其6b编码为001100，0比1的数量多2，其极性为-，实际为-2 D.30.y：其6b编码为011110，1比0的数量多2，其极性为+，实际为+2 D.11.y：其6b编码为110100，1和0的数量一样，其极性为空，实际为0 3b4b举例： D.x.0：其4b编码为0100，0比1的数量多2，其极性为-，实际为-2 D.x.7：其4b编码为1110或0111，1比0的数量多2，其极性为+，实际为+2 D.x.6：其4b编码为0110，1和0的数量一样，其极性为空，实际为0 观察5b6b和3b4b的编码表可以发现，输出的6b编码和4b编码只存在两种形式： 极性码 0和1的数量不平衡的码字，编码表中不平衡数量仅为2，因此极性码的极性为±2 001100(+2)，011110(-2)等是6b极性码 0100(+2)，1110(-2)等是4b极性码 平衡码 0和1的数量平衡的码字，平衡码的极性为0 110100，101001等是6b平衡码 0110，0101等是4b平衡码 极性码 极性码按照码表编码，但最终输出的码字有两种。 直接编码出来原始的码字 直接编码后按位取反的码字 举例： D.24.y，原始6b编码为001100，其极性为-，另一种码字为110011，其极性为+ D.30.y：原始6b编码为011110，其极性为+，另一种码字为100001，其极性为- D.x.0：原始4b编码为0100，其极性为-，另一种码字为1011，其极性为+ D.x.7：原始4b编码为1110，其极性为+，另一种码字为0001，其极性为- 极性码是±极性（positive/negative disparity）的。 平衡码 虽然平衡码都是0和1的数量平衡的码，但他们码字中0和1的间隔不一定一致，可简单分为两种。 完美平衡码（Perfect Balance Code） 6b编码：010101，010101，101100等 4b编码：0101，1001等 不完美平衡码（Imperfect Balance Code） 6b编码：111000 4b编码：1100 平衡码是0极性/空极性（zero/null disparity）的。 特殊极性码 前面讨论过，D.x.7是一种特殊的极性码，他有两种原始码字。 D.x.P07：原始4b编码为1110，其极性为+，另一种码字为0001，其极性为- D.x.A07：原始4b编码为0111，其极性为+，另一种码字为1000，其极性为- 这种特殊的极性码是为了码间的直流平衡设计的，关于D.x.P07和D.x.A07，可以参考示例2中的实际使用。 极性控制 运行极性 运行极性/运行不一致性（Running Disparity，RD），指的是在编码产生码流的过程中，实时的码流极性。 比如编码D.30.6+D.11.4的码流，运行极性（RD）分析如下： 编码过程：011110+0110+110100+0010 假设初始极性为-1，则运行极性（RD）：RD = -1 + 2 + 0 + 0 - 2 = -1 运行长度 运行长度（Running Length，RL），指的是连续0或者1的数量，注意运行长度不止代表码字内的连续0,1数量，也代表码字间的连续0,1数量，是衡量整个数据流是否直流平衡的一种方式。 比如编码D.30.6+D.11.4的码流，运行长度（RL）分析如下： 编码过程：011110+0110+110100+0010 控制原则1 控制直流平衡，有两个方面的考虑： -2&lt;RD&lt;2，运行极性不超过±2，即总体码流的0,1数量相同 RL&lt;5，运行长度不超过5，即总体码流连续0,1数量不超过5 这里首先考虑RD的控制总体原则： 当前编码极性为空（0），则继承码流极性，当前编码不变 当前编码极性非空（±2），则保持码流极性平衡 若当前编码与码流极性相同，则按位取反，翻转极性 若当前编码与码流极性相反，则保持编码，保持极性 简单来说，就是0多了补1，1多了补0，0、1一样多则不变的意思。 示例1 假设发送码流8'h55,8'hC0,8'hF2,8'hF4，初始极性为RD=-1，编码极性简写为disp（disparity） 8'h55=8'b01010101 5B=5'b01010=5'd10，3B=3'b101=3'd5，D.10.5 5B编码：6B=6'b010101，disp=0，继承码流极性，RD=-1+0=-1 3B编码：4B=4'b1010，disp=0，继承码流极性，RD=-1+0=-1 8'hC0=8'b11000000 5B=5'b11000=5'd24，3B=3'b000=3'd0，D.24.0 5B编码：6B=6'b110011，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b0100，disp=-2，保持极性（当前码流RD=+1），RD=+1-2=-1 8'hF2=8'b11110010 5B=5'b11110=5'd30，3B=3'b010=3'd2，D.30.2 5B编码：6B=6'b011110，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b0101，disp=0，继承码流极性，RD=+1+0=+1 8'hF4=8'b11110100 5B=5'b11110=5'd30，3B=3'b100=3'd4，D.30.4 5B编码：6B=6'b011110，disp=+2，翻转极性（当前码流RD=+1），6B=6'b100001，disp=-2，RD=+1-2=-1 3B编码：4B=4'b0010，disp=-2，翻转极性（当前码流RD=-1），4B=4'b1101，disp=+2，RD=-1+2=+1 控制原则2 在控制原则1中，只讨论了RD控制，虽然正常的RD控制可保证RL&lt;5，但一些特殊情况需要进行特殊控制。 不完美平衡码 不完美平衡码的定义参考平衡码。不完美平衡码也必须按极性码的做法保持码流极性平衡，保持或翻转编码。 6b不完美平衡码举例： 假设发送码流8'A8,8'h38，初始极性为RD=-1，编码极性简写为disp（disparity） 8'hA8=8'b10101000 5B=5'b10101=5'd21，3B=3'b000=3'd0，D.21.0 5B编码：6B=6'b101010，disp=0，继承码流极性，RD=-1+0=-1 3B编码：4B=4'b1011，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 8'h38=8'b00111000 5B=5'b00111=5'd7，3B=3'b000=3'd0，D.7.0 5B编码：6B=6'b111000，disp=0 此时，如果按照disp=0，继承码流极性，当前编码不变的话，则前面4B的1011和6B的111000会形成1011_111000，构成RL=5，即连续5个1 因此，按极性码的做法保持码流极性平衡，此时应翻转编码，6B=6'b000111，disp=0，这样1011_000111，就不会有RL=5出现了 RD=+1+0=+1 3B编码：4B=4'b0100，disp=-2，保持极性（当前码流RD=+1），RD=+1-2=-1 4b不完美平衡码举例： 假设发送码流8'7B，初始极性为RD=-1，编码极性简写为disp（disparity） 8'h7B=8'b01111011 5B=5'b01111=5'd15，3B=3'b011=3'd3，D.15.3 5B编码：6B=6'b010111，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b1100，disp=0 此时，如果按照disp=0，继承码流极性，当前编码不变的话，则前面6B的010111和4B的1100会形成010111_1100，构成RL=5，即连续5个1 因此，按极性码的做法保持码流极性平衡，此时应翻转编码，4B=4'b0011，disp=0，这样010111_0011，就不会有RL=5出现了 RD=+1+0=+1 D.x.7 由于D.x.7原始4b编码为1110，其极性为+，另一种码字为0001，其极性为-。 这种码字存在连续的111或者000，可能会与前一个6B的完美平衡码末尾的11或00构成RL=5，因此需要使用备用编码。 D.x.P07：原始4b编码为1110，其极性为+，另一种码字为0001，其极性为-（主要编码） D.x.A07：原始4b编码为0111，其极性为+，另一种码字为1000，其极性为-（备用编码） 举例： 假设发送码流8'h8F，初始极性为RD=-1，编码极性简写为disp（disparity） 8'h8F=8'b10001111 5B=5'b10001=5'd17，3B=3'b111=3'd7，D.17.7 5B编码：6B=6'b100011，disp=0，继承码流极性，RD=-1+0=-1 3B编码：4B=4'b1110，disp=+2 此时，如果按照disp=+2，保持极性（当前码流RD=-1）的话，则前面6B的100011和4B的1110会形成100011_1110，构成RL=5，即连续5个1 但此时不能翻转编码，因为需要保持RD平衡 因此需要disp=+2但没有连续111的码字，即4B=4'b0111，这样100011_0111，就不会有RL=5出现了 RD=-1+2=+1 举例： 假设发送码流8'A8,8'5F，初始极性为RD=-1，编码极性简写为disp（disparity） 8'hA8=8'b10101000 5B=5'b10101=5'd21，3B=3'b000=3'd0，D.21.0 5B编码：6B=6'b101010，disp=0，继承码流极性，RD=-1+0=-1 3B编码：4B=4'b1011，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 8'h5F=8'b01011111 5B=5'b01011=5'd11，3B=3'b111=3'd7，D.11.7 5B编码：6B=6'b110100，disp=0，继承码流极性，RD=+1+0=+1 3B编码：4B=4'b1110，disp=+2 此时，如果按照disp=+2，翻转极性（当前码流RD=+1）的话，则前面6B的110100和4B的0001会形成110100_0001，构成RL=5，即连续5个0 但此时不能翻转编码，因为需要保持RD平衡 因此需要disp=-2但没有连续000的码字，即4B=4'b1000，这样100011_1000，就不会有RL=5出现了 RD=+1-2=-1 以上所有的控制原则可以保证RL&lt;5，完整的证明8b10b编码RL&lt;5可以参考直流平衡。 示例2 在示例1的基础上，添加8'h3B,8'6F，即发送码流8'h55,8'hC0,8'hF2,8'hF4,8'h3B,8'h6F。 8'h3B=8'b00111011 5B=5'b00111=5'd7，3B=3'b011=3'd3，D.7.3 5B编码：6B=6'b111000，disp=0，翻转极性（当前码流RD=+1），6B=6'b000111，disp=0，RD=+1+0=+1（不完美平衡码） 3B编码：4B=4'b0011，disp=0，继承码流极性，RD=+1+0=+1 8'h6F=8'b01101111 5B=5'b01101=5'd13，3B=3'b111=3'd7，D.13.7 5B编码：6B=6'b101100，disp=0，继承码流极性，RD=+1+0=+1 3B编码：4B=4'b1110，disp=+2，翻转极性（当前码流RD=+1），即4B=4'b0001，但前一个6B存在连续两个0，因此采用备用编码，4B=4'b1000，disp=-2，RD=+1-2=-1 控制码 控制码（控制字）是用于码流控制的码字，可以作为起始、结尾、分隔，部分码字还可以用于链路同步。 控制码采用与数据码不同的编码方式实现。 5b6b编码表： 3b4b编码表： 控制码主要分为两种，下面分别讨论。 K.28.y K.28.y是指输入数据5B部分为5b'11100=5'd28类型的控制码。 K.28.y的构造逻辑是5b6b编码表中制造与数据不同的编码方式（数据码中不会出现cdei=1111/0000）。 单一性 注意，与数据不同的编码方式仅代表5b6b数据码中不会出现1111/0000，码间仍然可能组合出1111/0000，因此，这种码字在解码端可能会出现混淆。 举例： 假设发送码流8'h1F,8'h88，初始极性为RD=-1 D.3.7+D.17.0 6B=6'b110001+4B=4'b1110+6B=6'b100011+4B=4'b0100，码流为...1100011110100010100... 可能误识别码流为001111_0100，即K28.0 编码图： 码流图： 可以避免混淆的码字具备单一性（singularity）。 K28.1，K28.5以及K28.7具有特殊的标志位（RL2+RL5，即...0011111...或...1100000...），这在其他码字以及码间都不可能出现 因此，K28.1，K28.5以及K28.7具备单一性（singularity） K28.1，K28.5以及K28.7也被称为逗号码（comma），只有逗号码可以用于链路同步，因为其他码不具备单一性（singularity） K.28.y 极性 如果连续发送K.28.y，有两种情况： 0极性，单码保持，±码字选择根据上一次rd决定，类似不完美平衡码 ±极性，双码翻转 同时，K28.7不能连续发送，会造成连续RL5，即...11111000001111100000...，一般实际使用K28.1，K28.5作为逗号码。 K.x.7 K.x.A07是指输入数据3B部分为3b'111=3'd111类型的控制码。 K.x.A07的构造逻辑是3b4b编码表中制造与数据不同的编码方式（数据码中不会出现eifghj=01_0111/10_1000）。 单一性 同样的，这种码字也不具备单一性（singularity）。这里就不举例了，可以参考K.28.y的例子。 K.x.7 极性 如果连续发送K.x.7，只有单码保持的平衡情况，±码字选择根据上一次rd决定，类似不完美平衡码 示例3 假设发送码流8'hC0,8'hE5,8'hE5(K),8'hE5(K),8'hBF,8'hBF(K),8'hBF(K)，初始极性为RD=-1，编码极性简写为disp（disparity） 8'hC0=8'b11000000 5B=5'b11000=5'd24，3B=3'b000=3'd0，D.24.0 5B编码：6B=6'b110011，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b0100，disp=-2，保持极性（当前码流RD=+1），RD=+1-2=-1 8'hE5=8'b11100101 5B=5'b11100=5'd28，3B=3'b101=3'd5，D.28.5 5B编码：6B=6'b001110，disp=0，继承码流极性，RD=-1+0=-1 3B编码：4B=4'b1010，disp=0，继承码流极性，RD=-1+0=-1 8'hE5=8'b11100101，K 5B=5'b11100=5'd28，3B=3'b101=3'd5，K.28.5 5B编码：6B=6'b001111，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b1010，disp=0，继承码流极性，RD=+1+0=+1 这种码字可以叫做K.28.5+ 8'hE5=8'b11100101，K 5B=5'b11100=5'd28，3B=3'b101=3'd5，K.28.5 5B编码：6B=6'b001111，disp=+2，翻转极性（当前码流RD=+1），6B=6'b110000，disp=-2，RD=+1-2=-1 3B编码：4B=4'b1010，disp=0，继承码流极性，RD=-1+0=-1 这种码字可以叫做K.28.5- 8'hBF=8'b10111111 5B=5'b10111=5'd23，3B=3'b111=3'd7，D.23.7 5B编码：6B=6'b111010，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b1110，disp=+2，翻转极性（当前码流RD=+1），4B=4'b0001，disp=-2，RD=+1-2=-1 8'hBF=8'b10111111，K 5B=5'b10111=5'd23，3B=3'b111=3'd7，K.23.7 5B编码：6B=6'b111010，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b0111，disp=+2，翻转极性（当前码流RD=+1），4B=4'b1000，disp=-2，RD=+1-2=-1 8'hBF=8'b10111111，K 5B=5'b10111=5'd23，3B=3'b111=3'd7，K.23.7 5B编码：6B=6'b111010，disp=+2，保持极性（当前码流RD=-1），RD=-1+2=+1 3B编码：4B=4'b0111，disp=+2，翻转极性（当前码流RD=+1），4B=4'b1000，disp=-2，RD=+1-2=-1 直流平衡 dc balance 问题1：RL&lt;5能保证吗？ 问题2：会出现RL=5的情况吗？ 编码器 缺图表 解码器 缺图表 帧结构 缺图表 未完待续…短期施工中…","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"design","slug":"ic/design","permalink":"https://blog.honk.wang/categories/ic/design/"},{"name":"serdes","slug":"ic/design/serdes","permalink":"https://blog.honk.wang/categories/ic/design/serdes/"}],"tags":[{"name":"8b10b","slug":"8b10b","permalink":"https://blog.honk.wang/tags/8b10b/"},{"name":"5b6b","slug":"5b6b","permalink":"https://blog.honk.wang/tags/5b6b/"},{"name":"3b4b","slug":"3b4b","permalink":"https://blog.honk.wang/tags/3b4b/"},{"name":"dc balance","slug":"dc-balance","permalink":"https://blog.honk.wang/tags/dc-balance/"}]},{"title":"Vimscript-AutoMatic-Verilog","slug":"ic/editor/vimscript-automatic","date":"2021-04-19T14:26:09.000Z","updated":"2024-07-14T03:19:53.500Z","comments":true,"path":"posts/vimscript-automatic/","link":"","permalink":"https://blog.honk.wang/posts/vimscript-automatic/","excerpt":"","text":"有问题先看文档，再看评论区，依旧有问题可留言。 最新脚本地址：GitHub 使用docsify优化文档结构，文档迁移至：automatic-verilog文档 此页面只保留评论区作为问题留言板。 2022.5.25更新：V1.5无法兼容之前的版本，请各位注意。 2022.12.6更新：当前最新代码可能与文档有部分不一致，暂时没时间更新文档，有问题留言反馈，谢谢。","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"editor","slug":"ic/editor","permalink":"https://blog.honk.wang/categories/ic/editor/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"},{"name":"vimscript","slug":"vimscript","permalink":"https://blog.honk.wang/tags/vimscript/"}]},{"title":"Windows必装","slug":"tools/tools","date":"2020-06-13T12:07:15.000Z","updated":"2024-07-14T02:40:19.869Z","comments":true,"path":"posts/windows-software/","link":"","permalink":"https://blog.honk.wang/posts/windows-software/","excerpt":"","text":"那些值得推荐，让人眼前一亮的软件。 日常 下载：qBittorrent，IDM，Xdown，NDM，PanDownload（作者被抓，别再用了），迅雷极速版（吸血雷，别再用了） 电脑：卡硬工具箱（一共包括了 BIOS工具、CPU检测、CPU超频工具、电池检测、性能测试等12个分类的工具，共计70余个小工具），WPD（Windows系统优化） 桌面：（希望桌面软件能有个集合体） 桌面文件分类：Fences 隐藏状态栏：TranslucentTB Todo List：小黄条 壁纸：Wallpaper Engine 搜索：Everything，Listary 文件：XYplorer 卸载：Geek Uninstaller 安全：火绒（推荐弹窗拦截） 编辑 编辑：Gvim（编辑器之神），Emacs（神之编辑器），Typora（Markdown力荐），Neovim（Gvim平替），Sublime Text，Notepad++（作者反华，自行斟酌） 对比：Beyond Compare IDE：VSCode（力荐，可配合neovim），Anaconda（Jupyter Notebook超好用） 思维导图：XMind 博客： 截图：Snipaste（截图 + 贴图） GIF：LICEcap 键盘按键：Carnac 图床：PicGo 娱乐 聊天软件：TIM（简洁） 视频播放：PotPlayer（全面） 浏览器插件（按重要程度排序）： Extension Manager（扩展管理器） Tampermonkey（油猴脚本，相关脚本见后面Greasy Fork部分） 集装箱（一个插件，提供一揽子服务） bilibili pakku（哔哩哔哩弹幕过滤器 ） 哔哩哔哩助手（最好用的B站扩展程序） MONKNOW（新标签页），Adblock+（广告拦截），Pinbox（跨平台收藏），ImageAssistant（图片助手），GitHub加速，网盘直链下载助手，Decentraleyes（CDN加速，主要用于StackOverflow） Greasy Fork：Bilibili Evolved，百度系网站去广告，AC-baidu（搜索，重定向优化），Endless Google And Baidu，（使用AC-baidu则不需要此脚本），百度文库（已挂，请主动为文库付费）","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.honk.wang/categories/tools/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://blog.honk.wang/tags/windows/"},{"name":"software","slug":"software","permalink":"https://blog.honk.wang/tags/software/"}]},{"title":"Vim-Adventure","slug":"ic/editor/vim-adventure","date":"2020-05-30T12:07:39.000Z","updated":"2024-07-16T14:58:59.323Z","comments":true,"path":"posts/vim-adventure/","link":"","permalink":"https://blog.honk.wang/posts/vim-adventure/","excerpt":"","text":"前言 Vim作为编辑器来说，学习曲线确实很陡。但入门之后Vim会越用越顺手，根据个人配置的Vim也会越来越好用。vim-adventure提供了一个学习和游戏结合的环境（虽然最后的游戏难度可能会让人望而却步。。），可以用以入门vim的操作 游戏官网入口：Learn VIM while playing a game - VIM Adventures 参考攻略入口：最好的Vim学习教程-Vim Adventures 全攻略（附彩蛋） 在玩vim-adventure的过程中学习（或复习）了一些Vim的基础知识，在本文记录笔记，作为以后万一遗忘了的搜索材料。 关卡 Level1(h,j,k,l) 使用h，j，k，l键使光标单格进行上下左右的移动，类似于方向键。 注意如果光标在行末而每一行的长度不同的话，光标会根据长度最长的行自动调整其跳转位置。 Level2(w,b,e) 使用w，b，e键使光标按词进行移动。 w使光标跳转到下个词（word）开头。 b使光标跳转到当前词开头，如果已经在当前词开头（back），则跳转到前个词开头。 e使光标跳转到当前词结尾，如果已经在当前词结尾（edge），则跳转到下个词结尾。 注意w，b，e会将标点（如引号&quot;，逗号,还有空格&lt;space&gt;等）当成一整个词。 Level3 &amp; Level 4(W,B,E,x,r) 使用W，B，E键使光标按整词进行移动。整体的移动方式类似w，b，e 与w，b，e不同的是，W，B，E会包含标点在词内，不会将标点单独当成一整个词 使用x键删除单个字符，使用r键替换单个字符 x的作用是删除（cross）当前光标下的单个字符。等效于输入dl；大写X的作用是删除当前光标前一个光标下的单个字符。 r的作用是替换（replace），按r后输入正确字符可以替换当前字符。 Level5(d) 使用d键配合其他按键进行删除操作 d的作用是删除（delete）字符/行/段落， 但是单独的d只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。 比如之前移动光标的w，b，e就是动作命令。因此 dw删除字符到下个词（delete word）开头。 db删除字符到当前词开头，如果已经在当前词开头（delete back），则删除字符到前个词开头。 de删除字符到当前词结尾，如果已经在当前词结尾（delete edge），则删除字符到下个词结尾。 同理，dW，dB，dE删除时会包含标点在词内，不会将标点单独当成一整个词 再比如如之前上下左右移动光标的h，j，k，l也是动作命令。因此 dh删除当前光标左边的字符，即删除当前光标之前的字符（delete h）。 dl删除当前光标右边的字符，即删除当前光标的字符（delete l），等效于x。 dj删除当前行及其下一行的所有字符（delete j）。 dk删除当前行及其上一行的所有字符（delete k）。 另外， 重复两次操作符代表对当前行操作，因此 dd删除当前行所有字符。 Level6(~,$,0,^,D) 使用~键对单个字符进行大小写转换 使用$键跳转到行尾 使用0键跳转到行首 使用^键跳转到行首非空字符 ~的操作类似于r的替换（replace），只针对单个字符使用，如果字符是大写则转换为小写，反之亦然。 同样的，$，0，^也是动作命令，也可以结合d来操作。因此 d$删除当前光标到行尾的所有字符（delete $）。 d0删除当前光标到行首的所有字符（delete 0）。 d^删除当前光标到行首非空字符的所有字符（delete ^）。 值得注意的是，D单键等效于d$的功能，之后还会见到一些类似功能。因此，每当想进行“剪切/删除/复制/添加” “到行尾”操作的时候，都可以先看看是不是可以使用大写字母替代其功能，减少操作次数。 小结1 ( operator + motion ) vim的基础操作模式可以分为两种。 单键操作 单键操作单个字符： x删除单个字符 r替代单个字符 ~单个字符大小写转换 单键操作跳转动作（动作命令）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 操作符+动作命令 d删除操作符，配合动作命令完成删除 Level7(f,t,F,T,,,;,z,%,g,G) 使用f键向后跳转到指定字符位置 使用t键向后跳转到指定字符的位置前 使用,键和;键重复查找跳转的操作 查找字符跳转操作包括f和t f的作用是向后查找（find）某个特定的单个字符的位置并跳转。比如按fa后，在查找到下一个字符“a”的位置后光标会跳转到其位置。F的操作与f相同，只是方向是向前查找。 t的作用是向后查找直到（till）某个特定单个字符位置之前的位置并跳转。比如按ta后，在查找到下一个字符“a”的位置后光标会跳转其位置之前的位置。T的操作与t相同，只是方向是向前查找。 在完成一次f或t的单个字符的查找跳转之后，再使用;可以重复查找操作，而再使用,可以反向重复查找操作。比如按fa之后，光标会跳转到下一个字符&quot;a&quot;的位置；这时按;则等效重复fa的操作，查找到再下一个字符&quot;a&quot;的位置；而按,则等效重复Fa的操作，查找到上一个字符&quot;a&quot;的位置。 值得注意的是，只要操作过f或者t，操作就会被记录在寄存器中，因此这时可以随时使用;或者,重复这个操作。 同样的，f，t，F，T也是动作命令，也可以结合d来操作。因此 df+特定字符删除当前光标到下一个查找到的特定字符。比如dfa（delete find a），会从当前光标删除字符到下一个字符&quot;a&quot;所在位置。 dt+特定字符删除当前光标直到下一个查找到的特定字符之前的位置。比如dta（delete till a），会从当前光标删除字符直到下一个字符&quot;a&quot;所在位置之前的位置。 dT和dF的原理跟上面两个指令相同，只是查找方向相反 使用z键配合其他按键进行窗口调整操作 z的作用是调整窗口页面视角的位置（scroll，发音类似zcroll）。类似的，z只是一个操作符（operator），会根据实际的动作(motion)命令来产生效果。z的用法比较特殊，主要是以下几个 zz调整窗口页面视角使当前行在居中位置。（重复两次操作符代表对当前行操作） zt调整窗口页面视角使当前行在最顶层（scroll top）。 zb调整窗口页面视角使当前行在最底层（scroll bottom）。 使用%键在括号间匹配跳转 %的作用是括号匹配跳转（match）。%主要用于在编程中方便地在匹配的括号（包括&#123;&#125;，()）或是成对的标签之间跳转。比如在字符&#123;处按%，则会跳转到与之对应的&#125;处。 在不同的编程语言中，匹配的方式是不同的。在vim中可以通过配置文件自行添加标签匹配，比如在verilog中，begin和end就是一对匹配的标签，添加后即可匹配跳转。 使用g键进行全文跳转 g的作用是全文跳转（go）。类似的，单独的g只是一个操作符（operator），会根据实际的动作(motion)命令来产生效果。g的用法同样比较特殊，主要是以下几个 gg使光标跳转到全文的开头。 G使光标跳转到全文的结尾。 其实G可以配合数字使用跳转到指定行，不过当前这关还没有引入数字。比如5G可以跳转到第5行。 同样的，g，G也是动作命令，也可以结合d来操作。因此 dgg删除当前光标到全文的开头的所有字符。（delete gg） dG删除当前光标到全文的结尾的所有字符。 （delete G） Level8(*,#,n,N) 使用*键搜索距离光标最近的词，同时跳转过去（正向）。 使用#键搜索距离光标最近的词，同时跳转过去（反向）。 使用n键和N键重复搜索跳转的操作 整词搜索跳转操作包括*和# *的作用是向后查找某个特定的词的位置并跳转。 #的操作与*相同，只是方向是向前查找。 在完成一次*或#的整词搜索跳转之后，再使用n（next）可以重复搜索操作，而再使用N可以反向重复查找操作。比如按*之后，光标会跳转到下一个距离最近词的位置；这时按n则等效重复*的操作，查找到再下一个词的位置；而按N则等效重复#的操作，查找到上一个词的位置。 Level9( number ) 数字操作 数字操作是一个强大的重复功能，几乎之前所有的动作命令都可以通过数字进行重复，而通过操作符+动作命令的操作同样可以通过数字进行多次重复操作。以之前每个level的一些命令为例 j使光标进行向下的移动，而2j则使光标进行向下的移动2次 w使光标跳转到下个单词（word）开头，而3w则使光标跳转到往下第3个单词（3 word）的开头 x的作用是删除（cross）当前光标下的单个字符，而5x则是删除（cross）当前光标往后的5个字符 r的作用是替换（replace），而5r则是替换（replace）当前光标往后的5个字符为同一个字符 dw删除字符到下个单词（delete word）开头，而5dw或d5w则是删除字符到下5个词（5 delete word / delete 5 word）开头，简单来说就是删除5个词 dj删除当前行及其下一行的所有字符（delete j），而6dj或d6j则是删除当前行及其下6行的所有字符（6 delete j/ delete 6 j），简单来说就是加上当前行删7行 dd删除当前行所有字符，而6dd或d6d则是删除当前6行的所有字符，简单来说就是加上当前行删6行 $使光标跳转到行尾，而7$则是使光标跳转到往下第7个行尾 fa（find a）在查找到下一个字符“a”的位置后光标会跳转到其位置，而3fa或f3a会查找到往后第3个字符“a”（3 find a / find 3 a）并跳转到其位置 dtb（delete till b）会从当前光标删除字符直到下一个字符&quot;b&quot;所在位置之前的位置，而d2tb（delete 2 till b）会从当前光标删除字符直到**下2个字符&quot;b&quot;**所在位置之前的位置。 5G可以跳转到第5行。 在完成一次*或#的整词搜索跳转之后，再使用n（next）可以重复搜索操作，而如果在这时使用5n，则会执行5次重复搜索操作。 加入数字的操作极大的减少了键盘的操作次数，可以通过数字进行大量的重复操作。 小结2( operator + number + motion) vim的基础操作模式可以分为几种。 单字符操作 x删除单个字符 r替代单个字符 ~单个字符大小写转换 特殊操作 z组合操作窗口调整（zz，zt，zb） g操作全文跳转（gg，G） %匹配跳转 跳转动作（动作命令）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 f，t，查找字符跳转；;，,，重复查找 gg，G，全文跳转 *，#，搜索词跳转；n，N，重复搜索 数字+操作符+动作命令 或 操作符+数字+动作命令 d删除操作符，配合动作命令（3中的任何动作）以及数字完成多次删除 Level10(p,P,y,:reg,&quot;1-9,&quot;&quot;,&quot;a-z) 使用p键进行粘贴操作 在文本编辑器中被删除的内容一般可以通过撤销来恢复，因此被删除的内容其实是被存在了寄存器（register）中；在vim中也类似，只是可以通过操作访问各个寄存器并实现特定的复制（剪切）及粘贴操作。 寄存器包括无名寄存器（unnamed，最常用的寄存器），小删除寄存器（small delete），数字寄存器（numbered，1-9），具名寄存器（named，a-z），黑洞寄存器（black hole）等。 这些都不需要记忆，当使用的时候自然就会明白这些寄存器是拿来做什么的。 p的作用是粘贴（paste）。粘贴的可以是删除（即剪切，针对d和x）掉的内容，也可以是复制（针对y）的内容，根据最新一次的操作决定。 p的粘贴操作在当前光标之后。 P的粘贴操作在当前光标之前。 &quot; 指定剪切/复制所使用的寄存器 :reg查看当前寄存器 &quot;1，&quot;2…&quot;9数字寄存器（numbered） &quot;的作用是指定寄存器，而:reg的作用是查看寄存器。以数字寄存器（numbered）为例 由上面的图可见，在这里通过dd指令删除了4行，而4行内容被依次记录在了数字寄存器1~4中，越新的内容记录的位置越前，即1号寄存器记录最新删除的内容。因此，数字寄存器的作用是记录历史删除（即剪切，针对d和x）或复制（针对y）的内容。 假如删除了4行然后想粘贴第1行内容到当前位置怎么办呢？现在已知第1行的内容已经在4号寄存器，因此只要使用&quot;4p（number 4 register paste）就可以了。 使用y键配合其他按键进行复制操作 y的作用是复制（yank）字符/行/段落，类似于d，单独的y只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。因此所有对d有效果的动作命令对y依然有效，只是动作从删除变为了复制。例如 yw复制字符到下个词（yank word）开头。 yj复制当前行及其下一行的所有字符（yank j）。 yy复制当前行所有字符。 yG复制当前光标到全文的结尾的所有字符。 （yank G） 类似的，使用数字重复操作也同样适用于y。同时复制的内容也会存入数字寄存器。同样的，通过p或者P进行复制内容的粘贴操作。 yw复制字符到下个单词（yank word）开头，而5yw或y5w则是复制字符到下5个词（5 yank word / yank 5 word）开头，简单来说就是复制5个词 yj复制当前行及其下一行的所有字符（yank j），而6yj或y6j则是复制当前行及其下6行的所有字符（6 yank j/ yank 6 j），简单来说就是加上当前行复制7行 yy复制当前行所有字符，而6yy或y6y则是复制当前6行的所有字符，简单来说就是加上当前行复制6行 值得注意的是，类似于D单键等效于d$的功能，Y单键等效于y$的功能。因此，可通过Y键进行从当前光标复制到行尾的操作，减少操作次数Y单键等效于yy的功能。因此，可通过Y键进行复制当前行所有字符的操作，减少操作次数。 简而言之，所有y相关操作均可参考d。 &quot;&quot;无名寄存器（unnamed） 最近一次删除（即剪切，针对d和x）或复制（针对y）的内容会保存在无名寄存器（unnamed），按p或P的时候调用的就是无名寄存器存储的值。 &quot;a，&quot;b…&quot;z具名寄存器（named） 删除（即剪切，针对d和x）或复制（针对y）的内容可以指定存在&quot;a-&quot;z的具名寄存器中，通过p或P粘贴时也可以指定具名寄存器粘贴。当某个具名寄存器已有内容时，&quot;a-&quot;z会替换寄存器内的内容，而&quot;A-&quot;Z则会在对应寄存器后进行追加。 例如上图的操作中，通过&quot;ayw复制词Through&lt;space&gt;替换a寄存器（register a yank word），通过&quot;Ayw复制词God!追加到a寄存器尾部，再次通过&quot;Ayw&quot;复制词all到a寄存器尾部，从而实现了从多个地方复制。在最后通过&quot;ap进行粘贴操作（register a paste）。 Level11(c,C,s,i,I,a,A,o,O) 插入模式 之前的操作均是在普通模式下进行的，即所有操作是对已经写好的文本进行剪切、复制、粘贴、转换等操作，并不进行新文本的插入。而要进行新文本的插入，则需要进入插入模式。使用一些按键（比如i，a，c）进入插入模式，通过&lt;Esc&gt;或者&lt;C-[&gt;回到普通模式。 使用c键配合其他按键进行删除然后进入插入模式的操作 c的作用是改变（change）字符/行/段落，类似于d，单独的c只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。因此所有对d有效果的动作命令对c依然有效，只是动作从删除变为了改变（即删除然后进入插入模式）。例如 cw删除字符到下个词（change word）开头，并进入插入模式。 cj删除当前行及其下一行的所有字符（change j）。 cc删除当前行所有字符，并进入插入模式。 cG删除当前光标到全文的结尾的所有字符，并进入插入模式（change G）。 同时，类似于d的是，通过c删除的内容也会存储在数字寄存器内。 值得注意的是，类似于D单键等效于d$的功能，C单键等效于c$的功能。因此，可通过C键进行从当前光标删除到行尾，并进入插入模式的操作，减少操作次数。 使用s键删除单个字符并进入插入模式 如果说c对应d+进入插入模式的话，s应该就是对应x+进入插入模式了。前者要进入插入模式插入文字，后者依旧保持普通模式，不进行文字插入。因此 dl删除当前光标右边的字符，即删除当前光标的字符（delete l），等效于x。 cl删除当前光标右边的字符并进入插入模式，即改变当前光标的字符（change l），等效于s。 使用i 键在当前字符前进入插入模式。 使用a 键在当前字符后进入插入模式。 i和a是最常用的进入插入模式插入文本的方法，注意i和a并不是操作符，因此并不能搭配动作指令，它们的指令效果是立刻生效的。 值得注意的是，类似于D单键等效于d$的功能，A单键等效于$a（注意a不是操作符，因此不能使用a$）的功能。因此，可通过A键进行从当前光标跳转到行尾，并在行尾后进入插入模式的操作，减少操作次数。 类似的，I单键等效于^i（注意i不是操作符，因此不能使用i^）的功能。因此，可通过I键进行从当前光标跳转到行首（非空格），并在行首前进入插入模式的操作，减少操作次数。 简而言之，通过i和a进行当前光标字符前插入和字符后插入，通过I和A进行行首插入和行末插入。 使用o 键新建空白行并进入插入模式。 o的作用是在当前光标下新建空白行并进入插入模式。O则是在上一行插入。 o的新建一行操作在当前光标之下。 O的新建一行操作在当前光标之上。 数字操作 普通模式的命令进入插入模式时仍可以通过数字进行重复。以之前的一些命令为例 cw删除字符到下个词（change word）开头，并进入插入模式；而c2w会删除到下2个词（change 2 word）开头，并进入插入模式。 a 在当前字符后进入插入模式。 而2a会进入插入模式，并在退回普通模式时插入2次内容。 o的新建一行操作在当前光标之下。而3o会进入插入模式，并在退回普通模式时候插入3行内容。 小结3( uppercase ) vim的模式有普通模式和插入模式。基础操作模式可以分为几种。 特殊操作 z组合操作窗口调整（zz，zt，zb） %匹配跳转 跳转动作（动作命令）+数字（可不加）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 f，t，查找字符跳转；;，,，重复查找 gg，G，全文跳转 *，#，搜索词跳转；n，N，重复搜索 单字符+数字（可不加）操作 x删除单个字符，r替代单个字符，s删除单个字符并进入插入模式 ~单个字符大小写转换 i和a进入插入模式（字符前/后） 数字+操作符+动作命令 或 操作符+数字+动作命令 d删除操作符，配合动作命令（2中的任何动作）以及数字完成多次删除 y复制操作符，配合动作命令（2中的任何动作）以及数字完成多次复制 c改变操作符，配合动作命令（2中的任何动作）以及数字完成多次改变（即删除+进入插入模式） 大写按键需要注意的是，有些大写按键等效于操作符+首尾动作命令的操作，有些则是反向操作： 小写按键 意义 大写按键 意义 w b e 字跳转 W B E 字跳转（带标点、空格） x 向后删除单字符 X 向前删除单字符 r 替换单字符 R 替换多个字符 f t 查找跳转 F T 反向查找跳转 p 粘贴在光标后 P 粘贴在光标前 i a 进入插入模式 I A 行首/行尾进入插入模式 o 下方新建行 O 上方新建行 d 删除操作符 D 等效d$，删除到行尾 y 复制操作符 Y 等效y$，复制到行尾 等效yy，复制当前行 c 改变操作符 C 等效c$，改变到行尾 上表也不需要记忆，在实际使用的时候会自然形成习惯，即用了小写的按键，自然会考虑大写按键的类似操作。 Level12（(,),&#123;,&#125;,[,],object,.） 使用(和)进行句子跳转的操作 句子跳转操作包括(和)。句子按照标点句号.，问号?以及感叹号!作为结尾标识。 (的作用是向前跳转到上一句(首个非空字符)。 )的作用是向后跳转到下一句(首个非空字符)。 同样的，(，)也是动作命令，也可以结合d、y、c等操作符来操作。同样的，此操作仍可以通过数字进行重复。因此 d3)向后删除3句话（delete 3 sentence forward）。 y2( 向前复制2句话（yank 2 sentence backward）。 使用&#123;和&#125;进行段落跳转的操作 段落跳转操作包括&#123;和&#125;。段落按照空行作为分隔标识。 &#123;的作用是向前跳转到上一段落。 &#125;的作用是向后跳转到下一段落。 &#123;，&#125;也是动作命令，也可以结合d、y、c等操作符来操作。同样的，此操作仍可以通过数字进行重复。与前述按句子操作类似，在此不赘述。 使用[]配合其他括号，包括[&#123;,&#125;]，[(，)]，[[，]]，进行查找未闭合括号跳转的操作 每一对括号在代码中应该是匹配的，通过[]搜索未闭合括号的的操作可以方便查询代码结构。 [的作用是向前匹配到上一个未闭合括号（括号为&#123;，(，[）。 ]的作用是向后跳转到下一个未闭合括号（括号为&#125;，)，]）。 object对象操作。i，inner object，a，an object 对象，需配合操作符使用 普通的操作符+动作命令的操作对象均是由按键决定的，比如词（w,b,e），首尾（0，^，$），搜索位置（f,t）等，但有时实际的操作对象可能要求要更精确一些。 在小结3中总结过通过操作符（d，y，c）配合动作命令和数字进行批量修改，但有时动作命令可能无法满足操作复杂度的要求。因此vim引入了对象（object）的概念。以w为例，w本身是动作命令，会使光标跳转到下个词（word）开头。 而配合动作命令则可以得到dw删除字符到下个词（delete word）开头。 假设现在的操作光标在词的中间位置，则dw无法进行完整的删除，如下图所示。 这时若将整个词（word）作为对象（object）进行处理，采用daw（delete an object word），则可以直接删除掉整个词。 常见的对象（object）包括括号（&#123;&#125;,(),[]），引号（''，&quot;&quot;），word（w），sentence(s)，paragraph（p）等。 a和i的区别在于是否包括对象本身（边缘）。下面部分演示使用未提及的可视模式（Visual Mode）来展示对象（object）选择功能。 .重复 .的作用是重复（repeat）最近一次进行的修改。修改内容可以是删除(d)，也可以是改变(c)，小结3中的操作符+数字+动作命令均可通过.进行重复。.操作与配合数字操作不同的是，.的操作效果更直观，且数量控制更精确，通常.操作会配合u（undo）撤销操作一起，即重复多了就撤销，不需要在意具体的重复次数。下面演示几个简单功能来说明.操作。 重复删除行，重复粘贴 重复改变词 重复行尾添加分号; Level13（null） 13在国外不吉利，没有这关 Level14（u,&lt;C-r&gt;,H,L,M,|,:count,/,?,m,`,'） u撤销 &lt;C-r&gt;取消撤销 u的作用是撤销（undo）最近一次进行的修改。而&lt;C-r&gt;的作用是重做（redo）撤销的操作。类似Windows中的通用命令&lt;C-z&gt;撤销和&lt;C-y&gt;重做。 使用H L M移动光标 使用:&lt;count&gt;&lt;CR&gt;进行行跳转 使用&lt;count&gt;|进行列跳转 以上几个命令除了:&lt;count&gt;&lt;CR&gt;平时使用较少，适合于进行某些需要精确行列号跳转的场景。 H的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的首行（High）。 L的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的尾行（Low）。 M的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的中间行（Middle）。 :&lt;count&gt;&lt;CR&gt;的count输入任意数字可以跳转到对应行，其功能类似于&lt;count&gt;G。 &lt;count&gt;|的count输入任意数字可以跳转到对应列。 使用/&lt;word&gt;&lt;CR&gt; 键全文搜索名称为&lt;word&gt;的词并跳转至第一个词（正向），同时高亮所有匹配的词。 使用?&lt;word&gt;&lt;CR&gt; 键全文搜索名称为&lt;word&gt;的词并跳转至第一个词（反向），同时高亮所有匹配的词。 /和?的搜索方式与*和#类似，因此依然可以使用n和N重复搜索跳转的操作。 使用m键在指定的位置设置标记。 使用`跳转到制定的标记位置。 使用'跳转到指定的标记位置的第一个非空字符。 m的作用是标记位置（mark），例如命令 ma (mark a)表示用 a 标记当前的光标位置。可以通过输入:mark&lt;CR&gt;来查看当前的使用的所有mark标记。 标记包括每个缓冲区的局部标记和全局标记。局部标记可使用a-z的所有小写字母标记，而全局标记可使用A-Z的所有-大写字母标记。简单来说，局部标记可在当前文件前后跳转，全局标记可在文件间跳转。标记完成后可通过`跳转到制定的标记位置，或通过'跳转到指定的标记位置的第一个非空字符。 补：可视模式演示 本游戏vim-adventure缺少了一个重要部分，即可视模式(Visual Mode)。 v 普通可视模式 V行可视模式 &lt;C-v&gt;(Linux or MAC)或&lt;C-q&gt;（Windows专用）列可视模式 可视模式的操作逻辑类似鼠标点选后修改，不过具体到vim上与其他编辑器略有不同（比如列操作时不会对所有行进行同时显示，只有退出可视模式后才会统一弹出）。这里只演示功能，不进行具体功能介绍，。 结语 本教程仅供入门，关于vim使用相关知识最全面的首推Drew Neil的Practical Vim一书，针对普通模式、插入模式、可视模式及命令行模式等多种模式、多种操作方式均有详细的技巧教程。当然因为书本身只针对vim的技术点，因此关于vim配置vimrc的相关知识就相对少一些，不过相信读完全书后每位读者都会有自己的认知和配置要求，就能自己动手开始定制自己的vim了。 完结撒花~2020/7/7","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"editor","slug":"ic/editor","permalink":"https://blog.honk.wang/categories/ic/editor/"}],"tags":[{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"}]},{"title":"hexo博客搭建","slug":"hexo/hexo-blog-construction","date":"2020-05-17T14:14:13.000Z","updated":"2024-08-08T03:13:23.923Z","comments":true,"path":"posts/hexo-blog-construction/","link":"","permalink":"https://blog.honk.wang/posts/hexo-blog-construction/","excerpt":"","text":"本文旨在列举博客搭建的所有参考资料来源。 PS：本人不会网页前端，所有来源均参考各位博客大佬及网络资源。 框架 入门 博主之前刚开始接触hexo时用的yilia主题，小歪的教程。 教你免费搭建个人博客，Hexo&amp;Github | 小歪的博客 文档 | Hexo 主题 butterfly🦋yiliareplica本站使用的主题butterfly，作者JerryC，基于hexo-theme-melod升级。 Butterfly - A Simple and Card UI Design theme for Hexo jerryc127/hexo-theme-butterfly: 🦋 A Hexo Theme: Butterfly JerryC - 今日事,今日畢 小歪教程使用的主题yilia，作者已停更多年。 litten/hexo-theme-yilia: 一个简洁优雅的hexo主题 A simple and elegant theme for hexo Litten的博客 GitHub风格的博客主题。 sabrinaluo/hexo-theme-replica: Github style replication for hexo theme 小白妹妹写代码 优化 美化全优化双部署SSL首推超逸的博客，详细且很照顾新手，本人也很有意思。 【源码开放】Hexo+Github 博客butterfly 和 matery 主题 搭建完全教程【整理】 | 超逸の博客 HCLonely大佬的一揽子美化教程也很好，包括访客地图、文章日历、投票系统、加载动画（新版butterfly已自带）、页脚跳动的❤、页脚显示网站运行时间、双评论系统、随机文章跳转、文章统计图等。 Hexo博客美化 | HCLonely Blog 小康的方法主要通过inject css和js进行美化，不用修改模板，很方便。另外可以辅以乐特的文章，自行修改。 Hexo博客之butterfly主题优雅魔改系列（持续更新） | 小康博客 Butterfly(蝴蝶)主题美化、优化、无修改源码 (持续更新中…) | Lete乐特 's Blog 其他优化参考： 关于我 Butterfly 主题的所有美化 | 小嘉的部落格 小弋の生活馆全样式预览 | 小弋の生活馆 Hexo+Butterfly主题美化 | 唐先森の博客 各种一揽子优化教程，包括图片加载、代码压缩、全站CDN加速、SEO、URL永久链接以及其他一些小技巧，不一一细说，自行查阅。 Hexo进阶之各种优化 | Sky03’s Blog 使用Jsdelivr/CDN加速博客访问速度 | 过客~励む GitHub+Coding双线部署。主要是注意域名解析出问题的时候证书生成会有问题，暂停解析一下就好。（最新已改为部署至Vercel） Hexo：将你的博客部署到 Vercel | Serok’s Blog 2019hexo博客部署到coding该绕的坑-奥怪的小栈 - 奥怪 - 博客园 hexo干货系列：（四）将hexo博客同时托管到github和coding - 简书 Coding Pages 申请 SSL 证书错误：urn:acme:error:unauthorized: Invalid response from http://xxxxx/_网络_TRHX’S BLOG-CSDN博客 升级https。 为自定义域名的Hexo博客升级到Https网站_网络_qq_37683287的博客-CSDN博客 SSL 证书 腾讯云实现全站 HTTPS 方案 - 产品简介 - 文档中心 - 腾讯云 功能 以下的是一些其他的附加功能，可按需添加。 hexo插件小功能卡通-Live2D 向你的Hexo里放上一只萌萌哒二次元看板娘! EYHN/hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo! Hexo博客yilia主题首页添加helper-live2d模型插件 - 简书 统计-hexo-chart 懒人大佬将matery主题中的文章发布统计图、标签统计图、文章分类统计图做成了插件。 HCLonely/hexo-charts: Render hexo posts, categories, and tags into charts. hexo-charts插件Demo | HCLonely Blog [Demo] 音乐-hexo-tag-aplayer 主题自带js和css，但仍需安装插件 MoePlayer/hexo-tag-aplayer: Embed aplayer in Hexo posts/pages 链接-hexo-abbrlink hexo的页面地址转换为永久链接，有效简化地址长度。 rozbo/hexo-abbrlink: create one and only link for every post for hexo hexo+yilia添加URL持久化 | 荷塘月色的博客 加密-hexo-blog-encrypt 你可能需要写一些私密的博客，通过密码验证的方式让人不能随意浏览。 hexo-blog-encrypt/ReadMe.zh.md at master · MikeCoder/hexo-blog-encrypt 备份-hexo-git-backup 备份hexo博客源文件，建议private。 Hexo 常用插件 | XJHui’s Blog coneycode/hexo-git-backup: you can use it to backup your blog into git. 置顶-hexo-generator-index-pin-top 文章置顶，主题自带支持，安装插件即可。 netcan/hexo-generator-index-pin-top: Index generator plugin for Hexo. Pin top version Butterfly 安裝文檔(三) 主題配置-1 | Butterfly 外链-hexo-filter-nofollow 自动为 Hexo 博客中的外链添加rel=&quot;external nofollow noreferrer&quot; 的插件,从而改善你的网站的安全性和 SEO。 hexo-filter-nofollow - Hexo 官方的 nofollow 插件 | Sukka’s Blog hexojs/hexo-filter-nofollow: Add nofollow attribute to all external links automatically. 贡献-hexo-githubcalendar 自动为 Hexo 博客添加github贡献日历。 教程：hexo-githubcalendar 插件 1.0 | 小冰博客 (zfe.space) Zfour/hexo-github-calendar: 基于hexo的github calendar贡献插件 双栏-hexo-butterfly-article-double-row butterfly主题文章双栏布局插件。 教程：butterfly主题文章双栏布局插件 | 小冰博客 (zfe.space) Zfour/hexo-butterfly-article-double-row: Change the layout of the hexo-theme-butterfly article to double columns (github.com) 分类-hexo-magnet 自动为 Hexo 博客主页添加分类磁贴。 教程：hexo-magnet 插件 1.0 | 小冰博客 (zfe.space) Zfour/hexo-magnet: 基于hexo的magnet插件 (github.com) 访客地图-Clustrmaps 访客地图用于统计访客来源。 hexo(butterfly)加入clustrmaps访问者地图_定位,html,javascript_cungudafa的博客-CSDN博客 Free Website Counter Showing Visitor Location on Map 评论系统-Valine 注意各位大佬的Valine-Admin的模板不一样，配置的环境变量也不同。只能选择一个部署，自行选择。 Valine Admin 邮件回复提醒 | Xuexi’s Blog Valine添加博主标签及评论微信、QQ通知 | HCLonely Blog Valine评论之Valine-admin配置攻略 | 小康博客 Valine添加自定义表情 | 小康博客 优雅解决LeanCloud流控问题 | 小康博客 Valine 一款快速、简洁且高效的无后端评论系统。 LeanCloud 评论系统-Twikoo 切换为twikoo主要是国内使用方便，全部都搭建在腾讯云上。另外可以通过企业微信直接推送微信，没有次数限制。 Twikoo 中文文档 搭建微信通知API实现Twikoo新消息提醒 | guole’s Blog 微信菌：利用企业微信搭建微信消息提醒API | 张洪Heo 说说-Artitalk 说说界面，发布心情、吐槽。 Artitalk.js 时间线-Timeline 发布建站历史的时间轴。 Responsive Vertical Timeline | CodyHouse 版本徽章-Badges 项目版本的徽章标志。已从shields.io换为badgen。 GitHub 项目徽章的添加和设置 - LPD-iOS Shields.io: Quality metadata badges for open source projects Badgen - Fast badge generating service 名言生成-诗词&一言 自动生成一句话的API接口，可以在butterfly中配置副标题source为下面的接口，也可以放在网站或文章任意位置。 为你的博客引入——今日诗词、每日一言（js插件分享） | cungudafa Hitokoto - 一言 今日诗词 - 一言API - 诗词实时智能推荐 - 今日诗词开放接口 - 今日诗词 API 图床-PicGo+CDN 方案很多，用腾讯/阿里云自己搭、白嫖jsDelivr等，自行选择。 github做Markdown图床 - 简书 Hexo 博客图片添加至图床—腾讯云COS图床使用。 使用PicGo+Github搭建免费图床 | 过客~励む Github+PicGo+cdn配置私人图床（丝滑操作撰写md文章） | cungudafa 简历-nimo-markdown-cv 使用wodeni的模板生成一个html文件即可。 wodeni/nimo-markdown-cv: Maintain your CV in Markdown Hexo博客添加自定义HTML页面_javascript_本该如此-CSDN博客 导航-WebstackPage 需要后台，使用WordPress、Laravel或者Typecho等均可。 WebStackPage/WebStackPage.github.io: ❤️静态响应式网址导航网站 - webstack.cc WordPress 版 WebStack 导航主题使用说明，更新于20200115 | 一为忆 Windows 系统本地安装 WordPress 博客的方法 - SHTION｜时讯联科 hui-ho/WebStack-Laravel: 一个开源的网址导航网站项目，您可以拿来制作自己的网址导航。 typecho使用WebStack搭建网址导航 - 游轶的小站 设计-Canva&Logosc 进行Banner和Logo等图标设计。 Canva在线平面设计软件_免费设计模板素材和海量正版图片 - Canva中文官网 LOGO设计神器！人工智能为您在线设计LOGO，设计名片，打造完整企业VI 手机-Termux 使用移动设备进行hexo博客的编写 如何在移动设备上进行 Hexo 博客编辑和部署 | 艾迪的小栈 加密-PageCrypt HTML的单页面加密。 PageCrypt - Password Protect HTML 问题 文章页面404 Hexo部署到Github的大小写问题 | Ushioの鸽子屋 (dyhnoah.github.io) 记 Hexo 部署网站到 GitHub 时遇到的大小写不敏感问题 | Docle の Blog 致谢 搭博客的过程就是参考一个大佬，然后发现另一个大佬的大佬，然后发现更多的大佬。 首先感谢主题butterfly的原作者JerryC，做了一个非常适合新手的hexo主题。 其余各位大佬的链接均在友链界面，在此一并感谢，帮助了本人很多。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://blog.honk.wang/tags/blog/"}]},{"title":"Cordic Algorithm","slug":"ic/design/cordic-algorithm","date":"2020-03-24T14:56:47.000Z","updated":"2024-07-14T03:34:45.911Z","comments":true,"path":"posts/cordic-algorithm/","link":"","permalink":"https://blog.honk.wang/posts/cordic-algorithm/","excerpt":"","text":"公式渲染引擎由Mathjax换为Katex,文章可能存在渲染问题，如有发现问题请留言。 前世今生 以下源自参考资料[6]：CORDIC技术并不是什么新鲜的东西。事实上它可以追溯到1957年由J.Volder发表的一篇文章。在上个世纪五十年代，在大型实际的计算机中的实行移位相加受到了当时技术上的限制，所以使用CORDIC变得非常必要。到了七十年代，Hewlett Packard和其他公司出产了手持计算器,许多计算器使用一个内部CORDIC单元来计算所有的三角函数(了解这件事的人们一定还记得，那时求一个角度的正切值需要延迟大约1秒中)。二十世纪八十年代，随着高速度乘法器与带有大存储量的通用处理器的出现，CORDIC算法变得无关紧要了。然而在二十一世纪的今天，对于FPGA来说，CORDIC一定是在DSP应用中(诸如多输入多输出（MIMO），波束形成以及其他自适应系统)计算三角函数的备选技术。 本文将详细介绍CORDIC算法，所有参考资料见文章尾部。 Cordic详解 圆周坐标系 从坐标旋转开始 如下图，一个直角坐标点(x1,y1)(x_1,y_1)(x1​,y1​)逆时针旋转θθθ角度到点(x2,y2)(x_2,y_2)(x2​,y2​)，如何计算(x2,y2)(x_2,y_2)(x2​,y2​)呢？ 公式如下： x2=x1cosθ−y1cosθy2=x1sinθ+y1cosθx_2 = x_1cosθ-y_1cosθ \\\\ y_2 = x_1sinθ+y_1cosθ x2​=x1​cosθ−y1​cosθy2​=x1​sinθ+y1​cosθ 其实只需要一点高中的知识就能推导这个公式了。 假设底角为ααα，旋转半径为111，则 x2=cos(α+θ)=cos(α)cos(θ)−sin(α)sin(θ)=x1cosθ−y1cosθy2=sin(α+θ)=sin(α)cos(θ)+cos(α)sin(θ)=x1sinθ+y1cosθx_2=cos(α+θ) = cos(α)cos(θ) - sin(α)sin(θ) =x_1cosθ-y_1cosθ \\\\ y_2=sin(α+θ) = sin(α)cos(θ) + cos(α)sin(θ) =x_1sinθ+y_1cosθ x2​=cos(α+θ)=cos(α)cos(θ)−sin(α)sin(θ)=x1​cosθ−y1​cosθy2​=sin(α+θ)=sin(α)cos(θ)+cos(α)sin(θ)=x1​sinθ+y1​cosθ 上面的公式也可以写成矩阵的形式，即 [x2y2]=[cosθ−sinθsinθcosθ][x1y1]\\left[ \\begin{matrix} x_2\\\\ y_2 \\end{matrix} \\right] = \\left[ \\begin{matrix} cosθ&amp;-sinθ\\\\ sinθ&amp;cosθ \\end{matrix} \\right] \\left[ \\begin{matrix} x_1\\\\ y_1 \\end{matrix} \\right] [x2​y2​​]=[cosθsinθ​−sinθcosθ​][x1​y1​​] 以上公式对应逆时针旋转。若是顺时针旋转，则公式应为 [x1y1]=[cosθsinθ−sinθcosθ][x2y2]\\left[ \\begin{matrix} x_1\\\\ y_1 \\end{matrix} \\right] = \\left[ \\begin{matrix} cosθ&amp;sinθ\\\\ -sinθ&amp;cosθ \\end{matrix} \\right] \\left[ \\begin{matrix} x_2\\\\ y_2 \\end{matrix} \\right] [x1​y1​​]=[cosθ−sinθ​sinθcosθ​][x2​y2​​] 那么已知旋转角θθθ，如何通过FPGA来计算x2x_2x2​和y2y_2y2​呢？答案就是反复迭代。 二分角度旋转 假设(x1,y1)=(100,200)(x_1,y_1)=(100,200)(x1​,y1​)=(100,200)，要求其极坐标系下的坐标(ρ,θ)(ρ,θ)(ρ,θ)。当然，求θθθ的过程也就是求arctan(y/x)arctan(y/x)arctan(y/x)的过程。首先通过计算器得到结果(ρ,θ)=(223.61,63.435)(ρ,θ) = (223.61,63.435)(ρ,θ)=(223.61,63.435)。下面计算先只关注θθθ的旋转变化，不关注ρρρ的长度变化。这时最直观简单的想法就是先旋转一个角度进行一次尝试。 已知角度在(0°,90°)(0°,90°)(0°,90°)这个范围内，借鉴二分法的思想，先顺时针旋转45°45°45°进行尝试。根据之前推导的公式可知 [xy]=[cos(45°)sin(45°)−sin(45°)cos(45°)][100200]=[212.1370.711]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(45°)&amp;sin(45°)\\\\ -sin(45°)&amp;cos(45°) \\end{matrix} \\right] \\left[ \\begin{matrix} 100\\\\ 200 \\end{matrix} \\right] = \\left[ \\begin{matrix} 212.13\\\\ 70.711 \\end{matrix} \\right] [xy​]=[cos(45°)−sin(45°)​sin(45°)cos(45°)​][100200​]=[212.1370.711​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转的角度不够，则在此基础上继续顺时针旋转45/2=22.5°45/2=22.5°45/2=22.5°，此时角度为45+22.5=67.5°45+22.5=67.5°45+22.5=67.5°。根据推导的公式可知 [xy]=[cos(22.5°)sin(22.5°)−sin(22.5°)cos(22.5°)][212.1370.711]=[223.04−15.85]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(22.5°)&amp;sin(22.5°)\\\\ -sin(22.5°)&amp;cos(22.5°) \\end{matrix} \\right] \\left[ \\begin{matrix} 212.13\\\\ 70.711 \\end{matrix} \\right] = \\left[ \\begin{matrix} 223.04\\\\ -15.85 \\end{matrix} \\right] [xy​]=[cos(22.5°)−sin(22.5°)​sin(22.5°)cos(22.5°)​][212.1370.711​]=[223.04−15.85​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度超过了范围，则在此基础上逆时针回转22.5/2=11.25°22.5/2=11.25°22.5/2=11.25°，此时角度为45+22.5−11.25=56.25°45+22.5-11.25=56.25°45+22.5−11.25=56.25°。根据推导的公式可知 [xy]=[cos(11.25°)−sin(11.25°)sin(11.25°)cos(11.25°)][223.04−15.85]=[221.8527.967]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(11.25°)&amp;-sin(11.25°)\\\\ sin(11.25°)&amp;cos(11.25°) \\end{matrix} \\right] \\left[ \\begin{matrix} 223.04\\\\ -15.85 \\end{matrix} \\right] = \\left[ \\begin{matrix} 221.85\\\\ 27.967 \\end{matrix} \\right] [xy​]=[cos(11.25°)sin(11.25°)​−sin(11.25°)cos(11.25°)​][223.04−15.85​]=[221.8527.967​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转的角度又不够，则此基础上继续顺时针旋转11.25/2=5.625°11.25/2=5.625°11.25/2=5.625°，此时角度为45+22.5−11.25+5.625=61.875°45+22.5-11.25+5.625=61.875°45+22.5−11.25+5.625=61.875°。根据推导的公式可知 [xy]=[cos(5.625°)sin(5.625°)−sin(5.625°)cos(5.625°)][221.8527.967]=[223.526.0874]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(5.625°)&amp;sin(5.625°)\\\\ -sin(5.625°)&amp;cos(5.625°) \\end{matrix} \\right] \\left[ \\begin{matrix} 221.85\\\\ 27.967 \\end{matrix} \\right] = \\left[ \\begin{matrix} 223.52\\\\ 6.0874 \\end{matrix} \\right] [xy​]=[cos(5.625°)−sin(5.625°)​sin(5.625°)cos(5.625°)​][221.8527.967​]=[223.526.0874​] 这时纵坐标已经比较接近000了。按照这个模式继续算下去，可以不断逼近真实的结果。比如现在的结果范围为(ρ,θ)=(223.52,61.875±5.625)(ρ,θ)=(223.52,61.875±5.625)(ρ,θ)=(223.52,61.875±5.625)，已经接近实际结果(ρ,θ)=(223.61,63.435)(ρ,θ)=(223.61,63.435)(ρ,θ)=(223.61,63.435)了。旋转过程演示图如下。 因此通过多次迭代，可以逐渐逼近结果。但是如何计算上面的cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)等值？其实如果仔细观察，这些点都是固定的，因此他们的cos()cos()cos()和sin()sin()sin()也是固定的，所以只需要把要用的点的sin()sin()sin()和cos()cos()cos()提前计算好存起来，用时查表即可。Python实现如下。 12345678910111213141516171819202122232425262728293031323334353637383940import mathimport numpy as npITERATION_TIMES = 64i = 0d = 45cos = [0] * ITERATION_TIMESsin = [0] * ITERATION_TIMESdegree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): cos[i] = np.cos(d*np.pi/180) sin[i] = np.sin(d*np.pi/180) degree[i] = d; d = d/2#迭代计算for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x * cos[i] + y * sin[i] y_n = y * cos[i] - x * sin[i] z = z + degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z) else: x_n = x * cos[i] - y * sin[i] y_n = y * cos[i] + x * sin[i] z = z - degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z)print(z) 经过不同迭代次数，得到不同的结果。迭代次数越高，精度自然就越高。 迭代次数 计算角度（实际结果63.43494882292201） 16 63.433685302734375 32 63.43494881177321 64 63.43494882292201 长度缩放旋转 二分角度旋转的计算存在一个问题：计算量巨大。可以发现每一次旋转变换都需要进行4次浮点乘法运算，对于FPGA来说这个运算量过大。改进的方法就是通过变换坐标旋转的公式。 每次的旋转公式可以总结为 [xi+1yi+1]=[cos(θi)disin(θi)−disin(θi)cos(θi)][xiyi]=cos(θi)[1ditan(θi)−ditan(θi)1][xiyi]zi+1={zi+θi,if yi&gt;0zi−θi,if yi≤0where di={+1,if yi&gt;0−1,if yi≤0 ,θi=45°2i\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(θ_i)&amp;d_isin(θ_i)\\\\ -d_isin(θ_i)&amp;cos(θ_i) \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = \\begin{cases} z_i + θ_i, &amp; \\text{if $y_i$&gt;0} \\\\ z_i - θ_i, &amp; \\text{if $y_i$≤0} \\end{cases} \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}\\ ,θ_i=\\frac{45°}{2^i} [xi+1​yi+1​​]=[cos(θi​)−di​sin(θi​)​di​sin(θi​)cos(θi​)​][xi​yi​​]=cos(θi​)[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]zi+1​={zi​+θi​,zi​−θi​,​if yi​&gt;0if yi​≤0​where di​={+1,−1,​if yi​&gt;0if yi​≤0​ ,θi​=2i45°​ 这样进行转换后可以将cos(θ)cos(θ)cos(θ)从矩阵运算中提取出来并省略掉。为什么可以将cos(θ)cos(θ)cos(θ)省略掉呢？ 因为现在的计算只求θθθ的值，即旋转角度变化，不关心ρρρ长度的变化，省略掉的cos(θ)cos(θ)cos(θ)只是在长度上进行了放缩，并不影响其旋转的角度。因此转换公式变为 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]where di={+1,if yi&gt;0−1,if yi≤0\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases} [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]where di​={+1,−1,​if yi​&gt;0if yi​≤0​ 这种旋转方式被称为伪旋转(Pseudo-Rotation)。这样乘法的个数就从每一次旋转变换的4次变为了两次，存查找表的值也只需要tan(45),tan(22.5)tan(45),tan(22.5)tan(45),tan(22.5)…这样的值，减少了一半。过程演示图如下。 由上方过程演示图对比可以看出，旋转向量的长度在增长，但其旋转角度变化保持与之前一致。Python实现如下。 1234567891011121314151617181920212223242526272829303132333435363738import mathimport numpy as npITERATION_TIMES = 64i = 0d = 45tan = [0] * ITERATION_TIMESdegree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): tan[i] = np.tan(d*np.pi/180) degree[i] = d; d = d/2#迭代计算for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x + y * tan[i] y_n = y - x * tan[i] z = z + degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z) else: x_n = x - y * tan[i] y_n = y + x * tan[i] z = z - degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z)print(z) 结果与之前的二分角度旋转一致。 cordic旋转 经过了长度缩放的变换，算法成功将乘法运算减少了一半。那还能不能继续减少运算量呢？其实依旧可以从之前的长度缩放变换的转换公式入手。 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]where di={+1,if yi&gt;0−1,if yi≤0\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] where\\ d_i= \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases} [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]where di​={+1,−1,​if yi​&gt;0if yi​≤0​ 第一次旋转45°时，转换公式为 [xi+1yi+1]=[1tan(45)−tan(45)1][xiyi]=[11−11][xiyi]\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;tan(45)\\\\ -tan(45)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;1\\\\ -1&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] [xi+1​yi+1​​]=[1−tan(45)​tan(45)1​][xi​yi​​]=[1−1​11​][xi​yi​​] 可见此次转换其实不需要进行乘法运算，可以直接进行加减运算就可以得到结果。然而第二次旋转22.5°22.5°22.5°的时候，由于tan(22.5°)=0.4142135623731tan(22.5°)=0.4142135623731tan(22.5°)=0.4142135623731，这是一个不整的小数。因此需要复杂的乘法运算才能得到结果。 那有没有办法规避这种复杂乘法？当然是有的。注意一开始的二分法是通过对45°45°45°角进行二分得到了22.5°22.5°22.5°，但其实迭代旋转角度可以不选择22.5°22.5°22.5°，只要比45°45°45°角小就可以。假设选择tan(θ)=12tan(θ)=\\frac{1}{2}tan(θ)=21​的θθθ角（θ=26.565051177078°θ=26.565051177078°θ=26.565051177078°），则第二次旋转的公式变换为 [xi+1yi+1]=[1tan(26.565051177078°)−tan(26.565051177078°)1][xiyi]=[112−121][xiyi]\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;tan(26.565051177078°)\\\\ -tan(26.565051177078°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;\\frac{1}{2}\\\\ -\\frac{1}{2}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] [xi+1​yi+1​​]=[1−tan(26.565051177078°)​tan(26.565051177078°)1​][xi​yi​​]=[1−21​​21​1​][xi​yi​​] 同样的，每次选择tan(θ)=1,12,14tan(θ)=1,\\frac{1}{2},\\frac{1}{4}tan(θ)=1,21​,41​…依次类推，这样计算就在定点运算层面简化了。因为乘12\\frac{1}{2}21​的操作等于将数右移一位，乘14\\frac{1}{4}41​等于将数右移两位，以此类推。这样，复杂的乘法运算转化为了简单的移位和加减运算。通项转换公式变换为 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]=[1di2i−di2i1][xiyi]zi+1={zi+θi,if yi&gt;0zi−θi,if yi≤0where di={+1,if yi&gt;0−1,if yi≤0 ,θi=arctan(12i)\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;\\frac{d_i}{2^i}\\\\ -\\frac{d_i}{2^i}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = \\begin{cases} z_i + θ_i, &amp; \\text{if $y_i$&gt;0} \\\\ z_i - θ_i, &amp; \\text{if $y_i$≤0} \\end{cases} \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}\\ ,θ_i=arctan(\\frac{1}{2^i}) [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]=[1−2idi​​​2idi​​1​][xi​yi​​]zi+1​={zi​+θi​,zi​−θi​,​if yi​&gt;0if yi​≤0​where di​={+1,−1,​if yi​&gt;0if yi​≤0​ ,θi​=arctan(2i1​) 同样的，可以将θ=arctan(12i)θ=arctan(\\frac{1}{2^i})θ=arctan(2i1​)的值预先计算出来存起来，用时查表就可以。 tan(θ) θ 1 45.0° 0.5 26.56505117707799° 0.25 14.036243467926477° 0.125 7.125016348901798° 0.0625 3.5763343749973515° ‭0.03125‬ 1.7899106082460694° ‭0.015625‬ 0.8951737102110744° … … 过程演示图如下。 由上方过程演示图对比可以看出，cordic变换向量的长度与长度缩放旋转的变化类似，而其旋转角度发生了根本性变化，使得横纵坐标的变化的小数更整。Python实现如下。 12345678910111213141516171819202122232425262728293031323334353637import mathimport numpy as npITERATION_TIMES = 64i = 0d = 1degree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): degree[i] = math.atan(d) d = d/2#迭代计算d = 1for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x + (y &gt;&gt; d) y_n = y - (x &gt;&gt; d) z = z + degree[i] x = x_n y = y_n else: x_n = x - (y &gt;&gt; d) y_n = y + (x &gt;&gt; d) z = z - degree[i] x = x_n y = y_n d = d &gt;&gt; 1 print(z*180/np.pi) 至此基本讲清了cordic算法的本质原理（在圆周坐标下）。接下来补充一些其他cordic算法的相关内容。 参数、模式与坐标系 伸缩因子Kn 上一节中只关注了角度θθθ的求解，并没有关注到长度ρρρ的求解。实际上，如果考虑长度变化的话，那么cordic旋转公式应还原为（也就是将省略掉的cos(θ)cos(θ)cos(θ)补回来）： [xi+1yi+1]=[cos(θi)disin(θi)−disin(θi)cos(θi)][xiyi]=cos(θi)[1ditan(θi)−ditan(θi)1][xiyi]=cos(θi)[1di2i−di2i1][xiyi]zi+1=zi+diθiwhere di={+1,if yi&gt;0−1,if yi≤0, θi=arctan(12i)\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(θ_i)&amp;d_isin(θ_i)\\\\ -d_isin(θ_i)&amp;cos(θ_i) \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;\\frac{d_i}{2^i}\\\\ -\\frac{d_i}{2^i}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = z_i + d_iθ_i\\\\ \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases},\\ θ_i = arctan(\\frac{1}{2^i}) [xi+1​yi+1​​]=[cos(θi​)−di​sin(θi​)​di​sin(θi​)cos(θi​)​][xi​yi​​]=cos(θi​)[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]=cos(θi​)[1−2idi​​​2idi​​1​][xi​yi​​]zi+1​=zi​+di​θi​where di​={+1,−1,​if yi​&gt;0if yi​≤0​, θi​=arctan(2i1​) 还原为方程组的形式： xi+1=cos(θi)(xi+diyitan(θi)=cos(θi)(xi+diyi2i)yi+1=cos(θi)(yi−dixitan(θi)=cos(θi)(yi−dixi2i)zi+1=zi+diθiwhere di={+1,if yi&gt;0−1,if yi≤0, θi=arctan(12i)x_{i+1} = cos(θ_i)(x_i+d_iy_itan(θ_i)=cos(θ_i)(x_i+d_i\\frac{y_i}{2^i})\\\\ y_{i+1} = cos(θ_i)(y_i-d_ix_itan(θ_i)=cos(θ_i)(y_i-d_i\\frac{x_i}{2^i})\\\\ z_{i+1} = z_i + d_iθ_i\\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}, \\ θ_i = arctan(\\frac{1}{2^i})\\\\ xi+1​=cos(θi​)(xi​+di​yi​tan(θi​)=cos(θi​)(xi​+di​2iyi​​)yi+1​=cos(θi​)(yi​−di​xi​tan(θi​)=cos(θi​)(yi​−di​2ixi​​)zi+1​=zi​+di​θi​where di​={+1,−1,​if yi​&gt;0if yi​≤0​, θi​=arctan(2i1​) 假设进行64次迭代，则结果计算为 x64=∏n=063cos(θn)(xn+dyn2n)y64=∏n=063cos(θn)(yn−dxn2n)z64=z0+∑n=063dθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{64} = \\prod_{n=0}^{63}cos(θ_n)(x_n+d\\frac{y_n}{2^n})\\\\ y_{64} = \\prod_{n=0}^{63}cos(θ_n)(y_n-d\\frac{x_n}{2^n})\\\\ z_{64} = z_0 + \\sum_{n=0}^{63}dθ_n \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ x64​=n=0∏63​cos(θn​)(xn​+d2nyn​​)y64​=n=0∏63​cos(θn​)(yn​−d2nxn​​)z64​=z0​+n=0∑63​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 可以发现其实迭代过程的计算分为两部分，一部分是cordic的旋转变换，一部分是cordic的长度伸缩变换。 cordic长度伸缩变换： ∏n=063cos(θn)\\prod_{n=0}^{63}cos(θ_n) n=0∏63​cos(θn​) cordic旋转变换： ∏n=063(xn+dyn2n)∏n=063(yn−dxn2n)where{d=+1,if yn&gt;0d=−1,if yn≤0\\prod_{n=0}^{63}(x_n+d\\frac{y_n}{2^n})\\\\ \\prod_{n=0}^{63}(y_n-d\\frac{x_n}{2^n})\\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases} n=0∏63​(xn​+d2nyn​​)n=0∏63​(yn​−d2nxn​​)where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​ 由于在cordic旋转变换中，已知θn=arctan(12n)θ_n=arctan(\\frac{1}{2^n})θn​=arctan(2n1​)，因此长度伸缩变换可以变化为： ∏n=063(cos(θn))=∏n=063(11+tan2(θn))=∏n=063(11+(12n)2)\\prod_{n=0}^{63}(cos(θ_n))=\\prod_{n=0}^{63}(\\sqrt{\\frac{1}{1+tan^2(θ_n)}})=\\prod_{n=0}^{63}(\\sqrt{\\frac{1}{1+(\\frac{1}{2^n})^2}}) n=0∏63​(cos(θn​))=n=0∏63​(1+tan2(θn​)1​​)=n=0∏63​(1+(2n1​)21​​) 当n→∞n\\to∞n→∞，上面的式子是收敛的，当结束变换时，应当乘以收敛值的倒数以恢复长度变换带来的影响。恢复长度变换影响而乘的这个数就叫做伸缩因子KnK_nKn​，是一个固定常数。 Kn=lim⁡n→∞(∏0n(1+(12n)2))≈1.646761Kn≈0.6073K_n=\\lim_{n\\to∞}(\\prod_{0}^{n}(\\sqrt{1+(\\frac{1}{2^n})^2}))≈1.64676 \\\\ \\frac{1}{K_n}≈ 0.6073 Kn​=n→∞lim​(0∏n​(1+(2n1​)2​))≈1.64676Kn​1​≈0.6073 通过下表可见伸缩因子随迭代次数的变化 迭代次数 伸缩因子Kn 10 1.646759211139822 20 1.6467602581200669 50 1.6467602581210652 100 1.6467602581210652 可见伸缩因子随着迭代次数增加而变化越来越小，最终收敛。这样可以利用cordic旋转后通过乘以伸缩因子来保证长度变换也是正确的，从而求到长度ρρρ。最终的变换公式如下。 xn+1=Kn∏n=0n(xn+dyn2n)yn+1=Kn∏n=0n(yn−dxn2n)zn+1=z0+∑n=0ndθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n+d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n-d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 + \\sum_{n=0}^{n}dθ_n\\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​+d2nyn​​)yn+1​=Kn​n=0∏n​(yn​−d2nxn​​)zn+1​=z0​+n=0∑n​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 两种旋转模式 在圆周坐标系下的坐标旋转其实存在两个问题： 已知x1x_1x1​，y1y_1y1​，如何计算旋转角θθθ使得y=0y=0y=0？ 已知旋转角θθθ，x1x_1x1​，且y1=0y_1=0y1​=0，如何计算x2x_2x2​和y2y_2y2​？ 这是两个镜像问题，只是从两个方向来考虑。 通过不断进行cordic旋转变换逼近y=0y=0y=0的点（顺时针，逼近y=0y=0y=0点） 使结果纵坐标y→0y\\to0y→0的cordic旋转变换称为向量模式(vector mode)。 通过不断进行cordic旋转变换逼近旋转角θθθ（逆时针，逼近θ=0θ=0θ=0的点） 使结果角度θ→0θ\\to0θ→0的cordic旋转变换被称为旋转模式(rotation mode)。 圆周坐标的向量模式(vector mode)的公式为（上一节已经推导） 迭代式： {xi+1=xi+diyi2iyi+1=yi−dixi2izi+1=zi+dθiwhere{di=+1,if yi&gt;0di=−1,if yi≤0,θi=arctan(12i)\\begin{cases} x_{i+1} = x_i+d_i\\frac{y_i}{2^i}\\\\ y_{i+1} = y_i-d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i + dθ_i\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $y_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $y_i$≤0} \\end{cases},θ_i = arctan(\\frac{1}{2^i})\\\\ ⎩⎪⎨⎪⎧​xi+1​=xi​+di​2iyi​​yi+1​=yi​−di​2ixi​​zi+1​=zi​+dθi​​where{di​=+1,di​=−1,​if yi​&gt;0if yi​≤0​,θi​=arctan(2i1​) 结果式： xn+1=Kn∏n=0n(xn+dyn2n)yn+1=Kn∏n=0n(yn−dxn2n)zn+1=z0+∑n=0ndθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n+d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n-d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 + \\sum_{n=0}^{n}dθ_n \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​+d2nyn​​)yn+1​=Kn​n=0∏n​(yn​−d2nxn​​)zn+1​=z0​+n=0∑n​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 圆周坐标下旋转模式(rotation mode)的公式为 迭代式： {xi+1=xi−diyi2iyi+1=yi+dixi2izi+1=zi−diθiwhere{di=+1,if zi&gt;0di=−1,if zi≤0,θi=arctan(12i)\\begin{cases} x_{i+1} = x_i-d_i\\frac{y_i}{2^i}\\\\ y_{i+1} = y_i+d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i - d_iθ_i\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $z_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $z_i$≤0} \\end{cases},θ_i = arctan(\\frac{1}{2^i})\\\\ ⎩⎪⎨⎪⎧​xi+1​=xi​−di​2iyi​​yi+1​=yi​+di​2ixi​​zi+1​=zi​−di​θi​​where{di​=+1,di​=−1,​if zi​&gt;0if zi​≤0​,θi​=arctan(2i1​) 结果式： xn+1=Kn∏n=0n(xn−dyn2n)yn+1=Kn∏n=0n(yn+dxn2n)zn+1=z0−∑n=0ndθnwhere{d=+1,if zn&gt;0d=−1,if zn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n-d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n+d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 - \\sum_{n=0}^{n}dθ_n\\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_n$&gt;0} \\\\ d = -1, &amp; \\text{if $z_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​−d2nyn​​)yn+1​=Kn​n=0∏n​(yn​+d2nxn​​)zn+1​=z0​−n=0∑n​dθn​where{d=+1,d=−1,​if zn​&gt;0if zn​≤0​, θn​=arctan(2n1​) 三种坐标系 上文只讨论了圆周坐标系，实际cordic算法可用于三种坐标系，进行不同的复杂运算。 圆周坐标系(circular rotations) 线性坐标系(linear rotations) 双曲线坐标系(hyperbolic rotations) 圆周坐标系 之前的所有讨论均基于圆周坐标系。这里不再赘述。 线性坐标系 假设(x1,y1)=(250,100)(x_1,y_1)=(250,100)(x1​,y1​)=(250,100)，要求其在线性坐标系下的旋转角θθθ。首先根据观察可知tanθ=25tanθ=\\frac{2}{5}tanθ=52​ 。这时利用cordic旋转算法进行尝试。 类似的，先逆时针&quot;旋转&quot;45°45°45°进行尝试。根据之前推导的公式可知，此时显然x2=x1=100x_2=x_1=100x2​=x1​=100，y2=y1−x1tan45°=y1−x1y_2=y_1-x_1tan45°=y_1-x_1y2​=y1​−x1​tan45°=y1​−x1​。写成矩阵的形式： [xy]=[10−tan(45°)1][250100]=[10−11][250100]=[250−150]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -tan(45°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 100 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -1&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 100 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] [xy​]=[1−tan(45°)​01​][250100​]=[1−1​01​][250100​]=[250−150​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度超过了范围，则在此基础上顺时针&quot;回转&quot;tan(θ)=12tan(θ)=\\frac{1}{2}tan(θ)=21​的θθθ角（θ=26.565051177078°θ=26.565051177078°θ=26.565051177078°）。写成矩阵的形式： [xy]=[10tan(26.565051177078°)1][250−150]=[10121][250−150]=[250−25]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ tan(26.565051177078°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ \\frac{1}{2}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] [xy​]=[1tan(26.565051177078°)​01​][250−150​]=[121​​01​][250−150​]=[250−25​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度依然不够，则在此基础上顺时针&quot;回转&quot;tan(θ)=14tan(θ)=\\frac{1}{4}tan(θ)=41​的θθθ角（θ=14.036243467926477°θ=14.036243467926477°θ=14.036243467926477°）。写成矩阵的形式： [xy]=[10tan(14.036243467926477°)1][250−25]=[10141][250−25]=[25037.5]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ tan(14.036243467926477°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ \\frac{1}{4}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] [xy​]=[1tan(14.036243467926477°)​01​][250−25​]=[141​​01​][250−25​]=[25037.5​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转角度超过了范围，则在此基础上继续逆时针&quot;旋转&quot;tan(θ)=18tan(θ)=\\frac{1}{8}tan(θ)=81​的θθθ角（θ=7.125016348901798°θ=7.125016348901798°θ=7.125016348901798°）。写成矩阵的形式： [xy]=[10−tan(7.125016348901798°)1][25037.5]=[10−181][25037.5]=[2506.25]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -tan(7.125016348901798°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -\\frac{1}{8}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ 6.25 \\end{matrix} \\right] [xy​]=[1−tan(7.125016348901798°)​01​][25037.5​]=[1−81​​01​][25037.5​]=[2506.25​] 这时纵坐标已经比较接近000了。类似的，按照这个模式继续算下去，可以不断逼近真实的结果。比如现在的结果范围为(x,y)=(250,6.25±15.625)(x,y)=(250,6.25±15.625)(x,y)=(250,6.25±15.625)，已经接近实际结果(x,y)=(250,0)(x,y)=(250,0)(x,y)=(250,0)了。旋转过程演示图如下。 线性坐标系的&quot;旋转&quot;其实与圆周坐标系下的旋转含义并不相同了，因为这里的矩阵变化（所谓旋转）其实表现的就是一种迭代映射，其变换逻辑图如下： 注意，上述讨论分析的是使结果纵坐标y→0y\\to0y→0的cordic旋转变换，因此是向量模式(vector mode)。 线性坐标的向量模式(vector mode)的公式为（根据上述内容推导，zzz为tan(y1/x1)tan(y1/x1)tan(y1/x1)，注意cordic算法规定迭代n从1开始，且由于没有迭代乘法，并不存在伸缩因子KnK_nKn​） 迭代式： {xi+1=xiyi+1=yi−dixi2izi+1=zi+dixi2iwhere{di=+1,if yi&gt;0di=−1,if yi≤0\\begin{cases} x_{i+1} = x_i\\\\ y_{i+1} = y_i - d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i + d_i\\frac{x_i}{2^i}\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $y_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $y_i$≤0} \\end{cases} ⎩⎪⎨⎪⎧​xi+1​=xi​yi+1​=yi​−di​2ixi​​zi+1​=zi​+di​2ixi​​​where{di​=+1,di​=−1,​if yi​&gt;0if yi​≤0​ 结果式： xn+1=xn=x0yn+1=y0−∑n=0ndxn2nzn+1=z0+∑n=1nd2nwhere{d=+1,if yn&gt;0d=−1,if yn≤0x_{n+1} = x_n = x_0\\\\ y_{n+1} = y_0 - \\sum_{n=0}^{n}\\frac{dx_n}{2^n}\\\\ z_{n+1} = z_0 + \\sum_{n=1}^{n}\\frac{d}{2^n} \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases} xn+1​=xn​=x0​yn+1​=y0​−n=0∑n​2ndxn​​zn+1​=z0​+n=1∑n​2nd​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​ 圆周坐标下旋转模式(rotation mode)的公式为 迭代式： {xi+1=xiyi+1=yi+dxi2izi+1=zi−dxi2iwhere{d=+1,if zi&gt;0d=−1,if zi≤0\\begin{cases} x_{i+1} = x_i\\\\ y_{i+1} = y_i + d\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i - d\\frac{x_i}{2^i}\\\\ \\end{cases} \\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_i$&gt;0} \\\\ d = -1, &amp; \\text{if $z_i$≤0} \\end{cases} ⎩⎪⎨⎪⎧​xi+1​=xi​yi+1​=yi​+d2ixi​​zi+1​=zi​−d2ixi​​​where{d=+1,d=−1,​if zi​&gt;0if zi​≤0​ 结果式： xn+1=xn=x0yn+1=y0+∑n=0ndxn2nzn+1=z0−∑n=1nd2nwhere{d=+1,if zn&gt;0d=−1,if zn≤0x_{n+1} = x_n = x_0\\\\ y_{n+1} = y_0 + \\sum_{n=0}^{n}\\frac{dx_n}{2^n}\\\\ z_{n+1} = z_0 - \\sum_{n=1}^{n}\\frac{d}{2^n}\\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_n$&gt;0} \\\\ d = -1, &amp; \\text{if $z_n$≤0} \\end{cases} xn+1​=xn​=x0​yn+1​=y0​+n=0∑n​2ndxn​​zn+1​=z0​−n=1∑n​2nd​where{d=+1,d=−1,​if zn​&gt;0if zn​≤0​ 双曲坐标系 双曲坐标系的cordic旋转比较类似于圆周坐标系。 注意特殊的重复迭代。 应用问题 cordic功能表 图源为参考文献[6] ，侵删。 cordic计算范围及转换 cordic算法的计算是有范围限制的，超范围的值需要进行转换后才能利用cordic算法进行计算。 cordic计算误差 近似误差和舍入误差 见参考文献[7] FPGA实现 总结 未完待续…长期施工中… 参考资料 [1] 邹熙. 基于CORDIC的指数函数的FPGA实现[J]. 大众科技, 2008, 000(010):36-37. [2] 三角函数计算，Cordic 算法入门 [3] CORDIC_百度百科 [4] 周晓青, 李合生, 陶荣辉, et al. 基于CORDIC算法的双曲正余弦函数FPGA实现[J]. 太赫兹科学与电子信息学报, 2010(2):211-214. [5] cordic算法详解 转载 [6] Xilinx CORDIC算法 [7] Y. H. Hu, “The Quantization Effects of the CORDIC Algorithm”, in IEEE Trans. On Signal Processing, Vol 40, No 4, April 1992","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"design","slug":"ic/design","permalink":"https://blog.honk.wang/categories/ic/design/"}],"tags":[{"name":"cordic","slug":"cordic","permalink":"https://blog.honk.wang/tags/cordic/"}]},{"title":"hexo&butterfly","slug":"hexo/hexo-and-butterfly","date":"2019-11-10T07:10:42.000Z","updated":"2024-07-14T03:45:19.846Z","comments":true,"path":"posts/hexo-and-butterfly/","link":"","permalink":"https://blog.honk.wang/posts/hexo-and-butterfly/","excerpt":"","text":"hexo使用 流程 在git bash中跳转到hexo的博客文件夹，输入 12$ hexo new testINFO Created: ~\\desktop\\hexo\\blog\\source\\_posts\\test.md 找到该文章，打开，使用Markdown语法 注意每次generate之前最好清除掉之前的缓存。 1$ hexo clean 编辑完成后，执行以下命令（简写hexo g / hexo s） 1$ hexo generate 123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 打开http://localhost:4000/，文章已经成功发布。 然后发布到github上，执行以下命令（简写hexo d） 1$ hexo deploy 草稿 1$ hexo new (post) 其实是省略了post的写法，会新生成一个post页面。 如果暂时不想发布，只想作为草稿编辑的话，应使用 1$ hexo new draft XXX 通过以下命令查看带草稿页面的hexo预览。 1$ hexo server --draft 通过以下命令将草稿页面publish到正式的post文件中，并自动添加发布时间。 1$ hexo pubulish XXX newXXX butterfly使用 butterfly v3.0.0 地址迁移至Butterfly - A Simple and Card UI Design theme for Hexo butterfly地址迁移至Butterfly - A Simple and Card UI Design theme for Hexo。 以下内容均转自Butterfly - A Simple and Card UI Design theme for Hexo，小弋の生活馆全样式预览 | 小弋の生活馆以及 Hexo博客之butterfly主题优雅魔改系列（持续更新） | 小康博客，相关内容可自行去各位大佬博客查询。 渐变色 直接生成即可。彩色渐变字HTML代码生成器 渐变色文字 标签外挂(note) 主题自带note 主题自带的标签。 default 提示塊標籤 primary 提示塊標籤 success 提示塊標籤 info 提示塊標籤 warning 提示塊標籤 danger 提示塊標籤 另一种note 实现起来也很简单，只是对简单的 p 标签进行修改，为了方便添加颜色，这里提供了以上五种配色的样式。 使用起来也会简单，为了兼容各种平台，不推荐 tag 标签的写法。因此只又 html 标签的写法。这样做的好处是即便复制到各大平台也不会出现奇奇怪怪的标签符号或者报错。 note 效果展示： 绿色 红色 黄色 灰色 蓝色 小 tag 标签效果展示： 红色小标签 绿色小标签 蓝色小标签 黄色小标签 灰色小标签 渐变note（上标式外挂标签） 因为标签外挂的语法会导致复制到其他平台不便利，因此建议使用 HTML 写法。 默认情况 success error warning 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 动画标签 各种标签也可以用html的方式配合上动画，变成动画标签，效果还是比较夸张的！！！ 默认情况 success error warning volantis 主题的 note 因为标签外挂的语法会导致复制到其他平台不便利，因此只提供 HTML 写法。 默认 red info done success danger error radiation bug idea-yellow link- blue paperclip todo msg cyan guide download up undo 小标题Windows 10不是为所有人设计,而是为每个人设计嵌套测试 请坐和放宽，我正在帮你搞定一切… 隐藏按钮(tag-hide ) 主题自带的隐藏按钮。 inline 哪個英文字母最酷？ 查看答案 因為西裝褲(C裝酷) 門裏站着一個人? Click 閃 block 查看答案 傻子，怎麼可能有答案 toggle Butterfly安裝方法 在你的博客根目錄裏 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 如果想要安裝比較新的dev分支，可以 git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 标签 简单的： test1 3 1test1 3 2test1 3 3This is Tab 1.This is Tab 2.This is Tab 3. 带图标的： 第一個Tab炸彈tab名字為第一個Tab只有圖標 沒有Tab名字名字+icon 复选框 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 按钮 文内按钮 This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC 独占一行的按钮 JerryC JerryC JerryC 一行多个实心按钮 JerryC JerryC JerryC JerryC JerryC JerryC JerryC 一行多个空心按钮 JerryC JerryC JerryC JerryC JerryC JerryC JerryC inlineImg 你看我長得漂亮不 我覺得很漂亮 label 臣亮言：先帝 創業未半，而中道崩殂 。今天下三分，益州疲敝 ，此誠危急存亡之秋 也！然侍衞之臣，不懈於內；忠志之士 ，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。 宮中、府中，俱為一體；陟罰臧否，不宜異同。若有作奸 、犯科 ，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。 动画图标 起源于看到Sakura主题的Font Awesome动态图标很好看，例如主页图标，研究了一下，原来是一个开源的css代码，只要引入即可！ 自动动画 hover动画 Mermaid 画流程图、甘特图、饼状图等，代码绘图。 Mermaid Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs. 流程图 各类形状框 1234567891011graph LR A(A) B[B] C&#123;C&#125; D((D)) E&gt;E] F&#123;&#123;F&#125;&#125; G[/G/] H[\\H\\] I[/I\\] J[\\J/] graph TB A(A) B[B] C{C} D((D)) E&gt;E] F G[&#x2F;G&#x2F;] H[\\H\\] I[&#x2F;I\\] J[\\J&#x2F;] 流程图 12345678graph TB A[把大象放进去] --&gt; B&#123;&quot;冰箱大小？&quot;&#125; B -- 大 --&gt; C[关冰箱门] B --&gt;|小| D[换大冰箱] E -. 虚线 .- F G -. 虚线箭头 .-&gt; H style E fill:#f9f,stroke:#333,stroke-width:4px style G fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 graph TB A[把大象放进去] --&gt; B{&quot;冰箱大小？&quot;} B -- 大 --&gt; C[关冰箱门] B --&gt;|小| D[换大冰箱] E -. 虚线 .- F G -. 虚线箭头 .-&gt; H style E fill:#f9f,stroke:#333,stroke-width:4px style G fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 12345graph LR A[Hard edge] --&gt;|Link text| B(Round edge) B --&gt; C&#123;Decision&#125; C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] graph LR A[Hard edge] --&gt;|Link text| B(Round edge) B --&gt; C{Decision} C --&gt;|One| D[Result one] C --&gt;|Two| E[Result two] 饼图 123456pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5 pie title Key elements in Product X &quot;Calcium&quot; : 42.96 &quot;Potassium&quot; : 50.05 &quot;Magnesium&quot; : 10.01 &quot;Iron&quot; : 5","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"butterfly","slug":"butterfly","permalink":"https://blog.honk.wang/tags/butterfly/"}]}],"categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"design","slug":"ic/design","permalink":"https://blog.honk.wang/categories/ic/design/"},{"name":"serdes","slug":"ic/design/serdes","permalink":"https://blog.honk.wang/categories/ic/design/serdes/"},{"name":"editor","slug":"ic/editor","permalink":"https://blog.honk.wang/categories/ic/editor/"},{"name":"tools","slug":"tools","permalink":"https://blog.honk.wang/categories/tools/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"}],"tags":[{"name":"8b10b","slug":"8b10b","permalink":"https://blog.honk.wang/tags/8b10b/"},{"name":"5b6b","slug":"5b6b","permalink":"https://blog.honk.wang/tags/5b6b/"},{"name":"3b4b","slug":"3b4b","permalink":"https://blog.honk.wang/tags/3b4b/"},{"name":"dc balance","slug":"dc-balance","permalink":"https://blog.honk.wang/tags/dc-balance/"},{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"},{"name":"vimscript","slug":"vimscript","permalink":"https://blog.honk.wang/tags/vimscript/"},{"name":"windows","slug":"windows","permalink":"https://blog.honk.wang/tags/windows/"},{"name":"software","slug":"software","permalink":"https://blog.honk.wang/tags/software/"},{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://blog.honk.wang/tags/blog/"},{"name":"cordic","slug":"cordic","permalink":"https://blog.honk.wang/tags/cordic/"},{"name":"butterfly","slug":"butterfly","permalink":"https://blog.honk.wang/tags/butterfly/"}]}