{"meta":{"title":"HonkW","subtitle":"IC Learner","description":"言之命至，人随己愿<br>功不唐捐，自有因果","author":"HonkW","url":"https://blog.honk.wang","root":"/"},"pages":[{"title":"关于我","date":"2020-02-29T14:17:11.000Z","updated":"2020-11-02T16:03:57.537Z","comments":false,"path":"about/index.html","permalink":"https://blog.honk.wang/about/index.html","excerpt":"","text":"言之命至，人随己愿 —— 刘在石 功不唐捐，自有因果 📜 关于我 1234567891011121314module introduction( input [39:0] Name , //HonkW 48 6F 6E 6B 57 input [7:0] Age , //26 input Gender , //Male input [13*8-1:0] Address , //Sichuan,China input [29*8-1:0] Github , //https://github.com/honkw93 output [1:0] Motion ); localparam Happy = 2&#x27;d0; localparam Sad = 2&#x27;d1; localparam Indifferent = 2&#x27;d2; assign Motion = Happy; 🔑 技能学习 IC前端&amp;FPGA 编程语言工具编辑器仿真版本管理 Verilog-2001-Fluent Python-Familiar C-Familiar SystemVerilog-Learning SystemC Vimscript-Learning Tcl-Learning Makefile Shell Perl Synplify-Familiar Quartus-Know ISE -&gt; Vivado(Xilinx) Vim-Fluent Emacs ModelSim(Mentor Graphics)-Familiar iVerilog(Open source) VCS(Synopsys) NCVerilog(Cadence) ModelSim(Mentor Graphics)-Familiar gtkWave VCS-Verdi(Synopsys) VCS-DVE(Synopsys) SimVision(Cadence) Git-Familiar SVN CVS ✉️ 联系我 请发邮件📧或在留言板留言 ⚠️免责声明 本站以分享互联网经验、学习知识为目的，所有文章所涉及使用的工具、资源等均来自互联网， 仅供学习和研究使用，版权归作者所有。本站内的文章多为博主原创，仅供学习交流之用，不参与商业用途。 如果无意之中侵犯了您的版权，请来信告知。本站将在第一时间删除！ 遵守相关法律法规，由于本站资源部分来源于网络，开发也是使用开源模板，故无法核实资源侵权的真实性，无论出于何种目的要求本站删除内容，需要提供相关证明，否则不予处理。"},{"title":"说说","date":"2020-07-15T14:10:38.000Z","updated":"2020-10-31T11:25:51.324Z","comments":false,"path":"artitalk/index.html","permalink":"https://blog.honk.wang/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'A5qF4n8VoQeeuChOXlcmzlWs-MdYXbMMI', appKey: 'et9AgmOJvgSz3OYsYqwtAYuO', pageSize: 10 }) 注意，游客无法发布说说。请勿尝试。"},{"title":"工具箱","date":"2020-08-22T11:01:07.000Z","updated":"2020-08-29T02:20:31.205Z","comments":true,"path":"box/index.html","permalink":"https://blog.honk.wang/box/index.html","excerpt":"","text":"个人用工具盒子。访客请勿滥用。 导航 个人制作的一些导航网站。外链Storage站。 导航网站 个人网址导航 IC公众号导航 IC公众号-文章爬取 北美吐槽君-文章爬取 CloudFlare CloudFlare Workers实现的一些功能。 网盘 GoIndexGDIndexOneDrive IndexGoIndex，支持在线预览，播放等功能的Google Drive网盘。 Github：Aicirou/goindex-theme-acrou: This is a goindex theme.一个goindex的扩展主题。GDIndex，使用Vue编写的 Google Drive 目录。 Github：GDIndex: A Google Drive Index built with Vue Running on CloudFlare WorkersOneDrive相关网盘目录。暂未实现。 OneDrive-Index-Cloudflare-Worker Cloudflare 部署 FODI 后端 - LOGI 短链 个人ShortenLinks，将任何域名更换成一个t.cn/xxxx类的短网址。 建议走作者的ShortenLinks，个人的暂时有问题。 Github：Closty/duanwangzhi: Shorten your links without serves because it based on Cloudflare workers function with minimalist style.Hope u like:) 科学 需要不断更换域名。不放地址。 万能的CLOUDFLARE WORKERS+JSProxy代理？！ Github：EtherDream/jsproxy: 一个基于浏览器端 JS 实现的在线代理 页游 有意思的网页游戏。 页游 Vim-AdventuresGit-BranchingBash一起玩VIM Adventures学习Vim吧！一起Learn Git Branching学习Git吧！一起解决A command-line murder mystery谋杀案学习Bash吧！ 一起玩Wargames学习Bash吧！ 一起玩进入Terminus学习Bash吧！ 2048魔方吃豆人打砖块坦克大战2048，风靡一时的小游戏Cuber，可以随便转的网页虚拟魔方Pacman，吃豆人，儿时回忆Dx-Ball，打砖块，儿时回忆Battle-City，坦克大战，儿时回忆 服务器 谷歌 谷歌云、阿里云配置"},{"title":"分类","date":"2020-02-29T14:17:03.000Z","updated":"2020-03-08T13:00:33.007Z","comments":false,"path":"categories/index.html","permalink":"https://blog.honk.wang/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-01T08:34:47.000Z","updated":"2020-11-02T16:09:59.758Z","comments":true,"path":"link/index.html","permalink":"https://blog.honk.wang/link/index.html","excerpt":"","text":"IC相关从业者，不懂网页前端。本博客搭建感谢各位大佬无私分享。友链的彩灯根据各个博客首页风格选取，博主若不满意可留言变更。 ✉️ 联系我 请发邮件📧或在留言板留言 ⚠️免责声明 本站以分享互联网经验、学习知识为目的，所有文章所涉及使用的工具、资源等均来自互联网， 仅供学习和研究使用，版权归作者所有。本站内的文章多为博主原创，仅供学习交流之用，不参与商业用途。 如果无意之中侵犯了您的版权，请来信告知。本站将在第一时间删除！ 遵守相关法律法规，由于本站资源部分来源于网络，开发也是使用开源模板，故无法核实资源侵权的真实性，无论出于何种目的要求本站删除内容，需要提供相关证明，否则不予处理。 ℹ️我的Blog资料 Blog name: HonkW Blog link: https://honk.wang Blog avatar: https://cdn.jsdelivr.net/gh/HonkW93/blog@latest/img/avatar.jpg Blog description: 言之命至，人随己愿"},{"title":"Love","date":"2020-06-04T14:42:42.000Z","updated":"2020-11-02T16:10:27.839Z","comments":true,"path":"love/index.html","permalink":"https://blog.honk.wang/love/index.html","excerpt":"","text":"JaneR♥HonkW 相恋： function setTime() { var create_time = Math.round(new Date(Date.UTC(2019, 2, 15, 19, 0, 0)).getTime() / 1000); var timestamp = Math.round((new Date().getTime() + 8 * 60 * 60 * 1000) / 1000); currentTime = secondToDate((timestamp - create_time)); currentTimeHtml = currentTime[0] + ' 年 ' + currentTime[1] + ' 天 ' + currentTime[2] + ' 时 ' + currentTime[3] + ' 分 ' + currentTime[4] + ' 秒 '; document.getElementById(\"htmer_time\").innerHTML = currentTimeHtml; } function secondToDate(second) { if (!second) { return 0; } var time = new Array(0, 0, 0, 0, 0); if (second >= 365 * 24 * 3600) { time[0] = parseInt(second / (365 * 24 * 3600)); second %= 365 * 24 * 3600; } if (second >= 24 * 3600) { time[1] = parseInt(second / (24 * 3600)); second %= 24 * 3600; } if (second >= 3600) { time[2] = parseInt(second / 3600); second %= 3600; } if (second >= 60) { time[3] = parseInt(second / 60); second %= 60; } if (second > 0) { time[4] = second; } return time; } setInterval(setTime, 1000); ❤️ 历程 现在… 2020年10月1日，万州之行，岳父岳母 2020年8月30日，见见家长，周深专辑 2020年8月6日，夏日旅行 2020年7月30日，农历公历，同一天生日纪念~ 2020年6月15日，—❥ 2020年6月13日，北京来客，Space 2020年5月20日，节日纪念，好利来 2020年3月15日，周年纪念，未能见面 2019年8月4日，云南旅行，Double Date 2019年4月16日，百天纪念，旋转木马 2019年3月15日，相恋 💕 2019年1月7日，相识"},{"title":"留言板","date":"2020-03-13T11:42:37.000Z","updated":"2020-10-31T11:25:49.792Z","comments":true,"path":"messages/index.html","permalink":"https://blog.honk.wang/messages/index.html","excerpt":"","text":"留留言 聊聊天 留言须知 建议留下昵称与邮箱（QQ最佳，可收到邮件回复），方便及时收到博主回复。 请勿恶意评论。 请勿评论违法内容。"},{"title":"Music","date":"2020-07-13T13:20:51.000Z","updated":"2020-10-31T11:25:49.331Z","comments":true,"path":"music/index.html","permalink":"https://blog.honk.wang/music/index.html","excerpt":"","text":"网易云音乐歌单 qq音乐歌单"},{"title":"文章统计","date":"2020-05-14T16:49:31.000Z","updated":"2020-10-31T11:25:46.144Z","comments":false,"path":"statistics/index.html","permalink":"https://blog.honk.wang/statistics/index.html","excerpt":"","text":""},{"title":"零零碎碎的记录","date":"2020-04-26T15:38:21.000Z","updated":"2020-10-31T11:25:48.223Z","comments":false,"path":"photo/index.html","permalink":"https://blog.honk.wang/photo/index.html","excerpt":"","text":"生活 零零碎碎 韩孝周 关于韩孝周"},{"title":"Steam","date":"2020-08-11T14:55:50.000Z","updated":"2020-09-11T14:47:41.398Z","comments":true,"path":"steam/index.html","permalink":"https://blog.honk.wang/steam/index.html","excerpt":"","text":"最近在看 正在玩 以前玩过"},{"title":"标签","date":"2020-02-29T14:17:11.000Z","updated":"2020-03-08T13:01:04.304Z","comments":false,"path":"tags/index.html","permalink":"https://blog.honk.wang/tags/index.html","excerpt":"","text":""},{"title":"韩孝珠","date":"2020-04-26T15:38:21.000Z","updated":"2020-10-31T11:25:48.811Z","comments":false,"path":"photo/hyo/index.html","permalink":"https://blog.honk.wang/photo/hyo/index.html","excerpt":"","text":"最新综艺《首尔乡巴佬》，首尔出身的明星们去嘉宾的故乡，体验那里的生活的真人秀综艺 Running Man，一共上过两次，共四集 两天一夜cut"},{"title":"生活","date":"2020-04-26T15:38:21.000Z","updated":"2020-10-31T11:25:47.518Z","comments":false,"path":"photo/life/index.html","permalink":"https://blog.honk.wang/photo/life/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows必装","slug":"daily/tools","date":"2020-06-13T12:07:15.000Z","updated":"2020-10-31T11:25:55.688Z","comments":true,"path":"posts/Windows-Software/","link":"","permalink":"https://blog.honk.wang/posts/Windows-Software/","excerpt":"","text":"那些值得推荐，让人眼前一亮的软件。 日常 下载：qBittorrent，IDM，Xdown，NDM，PanDownload（作者被抓，别再用了），迅雷极速版（吸血雷，别再用了） 电脑：卡硬工具箱（一共包括了 BIOS工具、CPU检测、CPU超频工具、电池检测、性能测试等12个分类的工具，共计70余个小工具），WPD（Windows系统优化） 桌面：（希望桌面软件能有个集合体） 桌面文件分类：Fences 隐藏状态栏：TranslucentTB Todo List：小黄条 壁纸：Wallpaper Engine 搜索：Everything，Listary 文件：XYplorer 卸载：Geek Uninstaller 安全：火绒（推荐弹窗拦截） 编辑 编辑：Gvim（编辑器之神），Emacs（神之编辑器），Typora（Markdown力荐），Sublime Text，Notepad++（作者反华，自行斟酌） 对比：Beyond Compare IDE：VSCode（力荐），Anaconda（Jupyter Notebook超好用） 思维导图：XMind 博客： 截图：Snipaste（截图 + 贴图） GIF：LICEcap 键盘按键：Carnac 图床：PicGo 娱乐 聊天软件：TIM（简洁） 视频播放：PotPlayer（全面） Chrome插件：Tampermonkey（油猴脚本），集装箱（一个插件，提供一揽子服务），MONKNOW（新标签页），Adblock+（广告拦截），Pinbox（跨平台收藏），ImageAssistant（图片助手），GitHub加速，Extension Manager（扩展管理器），网盘直链下载助手，Decentraleyes（CDN加速，主要用于StackOverflow） Greasy Fork：Bilibili Evolved，百度系网站去广告，AC-baidu（搜索，重定向优化），Endless Google And Baidu，（使用AC-baidu则不需要此脚本），百度文库（已挂，请主动为文库付费）","categories":[{"name":"tools","slug":"tools","permalink":"https://blog.honk.wang/categories/tools/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://blog.honk.wang/tags/windows/"},{"name":"software","slug":"software","permalink":"https://blog.honk.wang/tags/software/"}]},{"title":"Vim-Adventure","slug":"IC/editor/vim-adventure","date":"2020-05-30T12:07:39.000Z","updated":"2020-10-31T11:25:55.425Z","comments":true,"path":"posts/Vim-Adventure/","link":"","permalink":"https://blog.honk.wang/posts/Vim-Adventure/","excerpt":"","text":"前言 Vim作为编辑器来说，学习曲线确实很陡。但入门之后Vim会越用越顺手，根据个人配置的Vim也会越来越好用。vim-adventure提供了一个学习和游戏结合的环境（虽然最后的游戏难度可能会让人望而却步。。），可以用以入门vim的操作 游戏官网入口：Learn VIM while playing a game - VIM Adventures 参考攻略入口：最好的Vim学习教程-Vim Adventures 全攻略（附彩蛋） 在玩vim-adventure的过程中学习（或复习）了一些Vim的基础知识，在本文记录笔记，作为以后万一遗忘了的搜索材料。 关卡 Level1(h,j,k,l) 使用h，j，k，l键使光标单格进行上下左右的移动，类似于方向键。 注意如果光标在行末而每一行的长度不同的话，光标会根据长度最长的行自动调整其跳转位置。 Level2(w,b,e) 使用w，b，e键使光标按词进行移动。 w使光标跳转到下个词（word）开头。 b使光标跳转到当前词开头，如果已经在当前词开头（back），则跳转到前个词开头。 e使光标跳转到当前词结尾，如果已经在当前词结尾（edge），则跳转到下个词结尾。 注意w，b，e会将标点（如引号&quot;，逗号,还有空格&lt;space&gt;等）当成一整个词。 Level3 &amp; Level 4(W,B,E,x,r) 使用W，B，E键使光标按整词进行移动。整体的移动方式类似w，b，e 与w，b，e不同的是，W，B，E会包含标点在词内，不会将标点单独当成一整个词 使用x键删除单个字符，使用r键替换单个字符 x的作用是删除（cross）当前光标下的单个字符。等效于输入dl；大写X的作用是删除当前光标前一个光标下的单个字符。 r的作用是替换（replace），按r后输入正确字符可以替换当前字符。 Level5(d) 使用d键配合其他按键进行删除操作 d的作用是删除（delete）字符/行/段落， 但是单独的d只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。 比如之前移动光标的w，b，e就是动作命令。因此 dw删除字符到下个词（delete word）开头。 db删除字符到当前词开头，如果已经在当前词开头（delete back），则删除字符到前个词开头。 de删除字符到当前词结尾，如果已经在当前词结尾（delete edge），则删除字符到下个词结尾。 同理，dW，dB，dE删除时会包含标点在词内，不会将标点单独当成一整个词 再比如如之前上下左右移动光标的h，j，k，l也是动作命令。因此 dh删除当前光标左边的字符，即删除当前光标之前的字符（delete h）。 dl删除当前光标右边的字符，即删除当前光标的字符（delete l），等效于x。 dj删除当前行及其下一行的所有字符（delete j）。 dk删除当前行及其上一行的所有字符（delete k）。 另外， 重复两次操作符代表对当前行操作，因此 dd删除当前行所有字符。 Level6(~,$,0,^,D) 使用~键对单个字符进行大小写转换 使用$键跳转到行尾 使用0键跳转到行首 使用^键跳转到行首非空字符 ~的操作类似于r的替换（replace），只针对单个字符使用，如果字符是大写则转换为小写，反之亦然。 同样的，$，0，^也是动作命令，也可以结合d来操作。因此 d$删除当前光标到行尾的所有字符（delete $）。 d0删除当前光标到行首的所有字符（delete 0）。 d^删除当前光标到行首非空字符的所有字符（delete ^）。 值得注意的是，D单键等效于d$的功能，之后还会见到一些类似功能。因此，每当想进行“剪切/删除/复制/添加” “到行尾”操作的时候，都可以先看看是不是可以使用大写字母替代其功能，减少操作次数。 小结1 ( operator + motion ) vim的基础操作模式可以分为两种。 单键操作 单键操作单个字符： x删除单个字符 r替代单个字符 ~单个字符大小写转换 单键操作跳转动作（动作命令）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 操作符+动作命令 d删除操作符，配合动作命令完成删除 Level7(f,t,F,T,,,;,z,%,g,G) 使用f键向后跳转到指定字符位置 使用t键向后跳转到指定字符的位置前 使用,键和;键重复查找跳转的操作 查找字符跳转操作包括f和t f的作用是向后查找（find）某个特定的单个字符的位置并跳转。比如按fa后，在查找到下一个字符“a”的位置后光标会跳转到其位置。F的操作与f相同，只是方向是向前查找。 t的作用是向后查找直到（till）某个特定单个字符位置之前的位置并跳转。比如按ta后，在查找到下一个字符“a”的位置后光标会跳转其位置之前的位置。T的操作与t相同，只是方向是向前查找。 在完成一次f或t的单个字符的查找跳转之后，再使用;可以重复查找操作，而再使用,可以反向重复查找操作。比如按fa之后，光标会跳转到下一个字符&quot;a&quot;的位置；这时按;则等效重复fa的操作，查找到再下一个字符&quot;a&quot;的位置；而按,则等效重复Fa的操作，查找到上一个字符&quot;a&quot;的位置。 值得注意的是，只要操作过f或者t，操作就会被记录在寄存器中，因此这时可以随时使用;或者,重复这个操作。 同样的，f，t，F，T也是动作命令，也可以结合d来操作。因此 df+特定字符删除当前光标到下一个查找到的特定字符。比如dfa（delete find a），会从当前光标删除字符到下一个字符&quot;a&quot;所在位置。 dt+特定字符删除当前光标直到下一个查找到的特定字符之前的位置。比如dta（delete till a），会从当前光标删除字符直到下一个字符&quot;a&quot;所在位置之前的位置。 dT和dF的原理跟上面两个指令相同，只是查找方向相反 使用z键配合其他按键进行窗口调整操作 z的作用是调整窗口页面视角的位置（scroll，发音类似zcroll）。类似的，z只是一个操作符（operator），会根据实际的动作(motion)命令来产生效果。z的用法比较特殊，主要是以下几个 zz调整窗口页面视角使当前行在居中位置。（重复两次操作符代表对当前行操作） zt调整窗口页面视角使当前行在最顶层（scroll top）。 zb调整窗口页面视角使当前行在最底层（scroll bottom）。 使用%键在括号间匹配跳转 %的作用是括号匹配跳转（match）。%主要用于在编程中方便地在匹配的括号（包括&#123;&#125;，()）或是成对的标签之间跳转。比如在字符&#123;处按%，则会跳转到与之对应的&#125;处。 在不同的编程语言中，匹配的方式是不同的。在vim中可以通过配置文件自行添加标签匹配，比如在verilog中，begin和end就是一对匹配的标签，添加后即可匹配跳转。 使用g键进行全文跳转 g的作用是全文跳转（go）。类似的，单独的g只是一个操作符（operator），会根据实际的动作(motion)命令来产生效果。g的用法同样比较特殊，主要是以下几个 gg使光标跳转到全文的开头。 G使光标跳转到全文的结尾。 其实G可以配合数字使用跳转到指定行，不过当前这关还没有引入数字。比如5G可以跳转到第5行。 同样的，g，G也是动作命令，也可以结合d来操作。因此 dgg删除当前光标到全文的开头的所有字符。（delete gg） dG删除当前光标到全文的结尾的所有字符。 （delete G） Level8(*,#,n,N) 使用*键搜索距离光标最近的词，同时跳转过去（正向）。 使用#键搜索距离光标最近的词，同时跳转过去（反向）。 使用n键和N键重复搜索跳转的操作 整词搜索跳转操作包括*和# *的作用是向后查找某个特定的词的位置并跳转。 #的操作与*相同，只是方向是向前查找。 在完成一次*或#的整词搜索跳转之后，再使用n（next）可以重复搜索操作，而再使用N可以反向重复查找操作。比如按*之后，光标会跳转到下一个距离最近词的位置；这时按n则等效重复*的操作，查找到再下一个词的位置；而按N则等效重复#的操作，查找到上一个词的位置。 Level9( number ) 数字操作 数字操作是一个强大的重复功能，几乎之前所有的动作命令都可以通过数字进行重复，而通过操作符+动作命令的操作同样可以通过数字进行多次重复操作。以之前每个level的一些命令为例 j使光标进行向下的移动，而2j则使光标进行向下的移动2次 w使光标跳转到下个单词（word）开头，而3w则使光标跳转到往下第3个单词（3 word）的开头 x的作用是删除（cross）当前光标下的单个字符，而5x则是删除（cross）当前光标往后的5个字符 r的作用是替换（replace），而5r则是替换（replace）当前光标往后的5个字符为同一个字符 dw删除字符到下个单词（delete word）开头，而5dw或d5w则是删除字符到下5个词（5 delete word / delete 5 word）开头，简单来说就是删除5个词 dj删除当前行及其下一行的所有字符（delete j），而6dj或d6j则是删除当前行及其下6行的所有字符（6 delete j/ delete 6 j），简单来说就是加上当前行删7行 dd删除当前行所有字符，而6dd或d6d则是删除当前6行的所有字符，简单来说就是加上当前行删6行 $使光标跳转到行尾，而7$则是使光标跳转到往下第7个行尾 fa（find a）在查找到下一个字符“a”的位置后光标会跳转到其位置，而3fa或f3a会查找到往后第3个字符“a”（3 find a / find 3 a）并跳转到其位置 dtb（delete till b）会从当前光标删除字符直到下一个字符&quot;b&quot;所在位置之前的位置，而d2tb（delete 2 till b）会从当前光标删除字符直到**下2个字符&quot;b&quot;**所在位置之前的位置。 5G可以跳转到第5行。 在完成一次*或#的整词搜索跳转之后，再使用n（next）可以重复搜索操作，而如果在这时使用5n，则会执行5次重复搜索操作。 加入数字的操作极大的减少了键盘的操作次数，可以通过数字进行大量的重复操作。 小结2( operator + number + motion) vim的基础操作模式可以分为几种。 单字符操作 x删除单个字符 r替代单个字符 ~单个字符大小写转换 特殊操作 z组合操作窗口调整（zz，zt，zb） g操作全文跳转（gg，G） %匹配跳转 跳转动作（动作命令）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 f，t，查找字符跳转；;，,，重复查找 gg，G，全文跳转 *，#，搜索词跳转；n，N，重复搜索 数字+操作符+动作命令 或 操作符+数字+动作命令 d删除操作符，配合动作命令（3中的任何动作）以及数字完成多次删除 Level10(p,P,y,:reg,&quot;1~9,&quot;&quot;,&quot;a~z) 使用p键进行粘贴操作 在文本编辑器中被删除的内容一般可以通过撤销来恢复，因此被删除的内容其实是被存在了寄存器（register）中；在vim中也类似，只是可以通过操作访问各个寄存器并实现特定的复制（剪切）及粘贴操作。 寄存器包括无名寄存器（unnamed，最常用的寄存器），小删除寄存器（small delete），数字寄存器（numbered，1-9），具名寄存器（named，a-z），黑洞寄存器（black hole）等。 这些都不需要记忆，当使用的时候自然就会明白这些寄存器是拿来做什么的。 p的作用是粘贴（paste）。粘贴的可以是删除（即剪切，针对d和x）掉的内容，也可以是复制（针对y）的内容，根据最新一次的操作决定。 p的粘贴操作在当前光标之后。 P的粘贴操作在当前光标之前。 &quot; 指定剪切/复制所使用的寄存器 :reg查看当前寄存器 &quot;1，&quot;2…&quot;9数字寄存器（numbered） &quot;的作用是指定寄存器，而:reg的作用是查看寄存器。以数字寄存器（numbered）为例 由上面的图可见，在这里通过dd指令删除了4行，而4行内容被依次记录在了数字寄存器1~4中，越新的内容记录的位置越前，即1号寄存器记录最新删除的内容。因此，数字寄存器的作用是记录历史删除（即剪切，针对d和x）或复制（针对y）的内容。 假如删除了4行然后想粘贴第1行内容到当前位置怎么办呢？现在已知第1行的内容已经在4号寄存器，因此只要使用&quot;4p（number 4 register paste）就可以了。 使用y键配合其他按键进行复制操作 y的作用是复制（yank）字符/行/段落，类似于d，单独的y只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。因此所有对d有效果的动作命令对y依然有效，只是动作从删除变为了复制。例如 yw复制字符到下个词（yank word）开头。 yj复制当前行及其下一行的所有字符（yank j）。 yy复制当前行所有字符。 yG复制当前光标到全文的结尾的所有字符。 （yank G） 类似的，使用数字重复操作也同样适用于y。同时复制的内容也会存入数字寄存器。同样的，通过p或者P进行复制内容的粘贴操作。 yw复制字符到下个单词（yank word）开头，而5yw或y5w则是复制字符到下5个词（5 yank word / yank 5 word）开头，简单来说就是复制5个词 yj复制当前行及其下一行的所有字符（yank j），而6yj或y6j则是复制当前行及其下6行的所有字符（6 yank j/ yank 6 j），简单来说就是加上当前行复制7行 yy复制当前行所有字符，而6yy或y6y则是复制当前6行的所有字符，简单来说就是加上当前行复制6行 值得注意的是，类似于D单键等效于d$的功能，Y单键等效于y$的功能。因此，可通过Y键进行从当前光标复制到行尾的操作，减少操作次数Y单键等效于yy的功能。因此，可通过Y键进行复制当前行所有字符的操作，减少操作次数。 简而言之，所有y相关操作均可参考d。 &quot;&quot;无名寄存器（unnamed） 最近一次删除（即剪切，针对d和x）或复制（针对y）的内容会保存在无名寄存器（unnamed），按p或P的时候调用的就是无名寄存器存储的值。 &quot;a，&quot;b…&quot;z具名寄存器（named） 删除（即剪切，针对d和x）或复制（针对y）的内容可以指定存在&quot;a-&quot;z的具名寄存器中，通过p或P粘贴时也可以指定具名寄存器粘贴。当某个具名寄存器已有内容时，&quot;a-&quot;z会替换寄存器内的内容，而&quot;A-&quot;Z则会在对应寄存器后进行追加。 例如上图的操作中，通过&quot;ayw复制词Through&lt;space&gt;替换a寄存器（register a yank word），通过&quot;Ayw复制词God!追加到a寄存器尾部，再次通过&quot;Ayw&quot;复制词all到a寄存器尾部，从而实现了从多个地方复制。在最后通过&quot;ap进行粘贴操作（register a paste）。 Level11(c,C,s,i,I,a,A,o,O) 插入模式 之前的操作均是在普通模式下进行的，即所有操作是对已经写好的文本进行剪切、复制、粘贴、转换等操作，并不进行新文本的插入。而要进行新文本的插入，则需要进入插入模式。使用一些按键（比如i，a，c）进入插入模式，通过&lt;Esc&gt;或者&lt;C-[&gt;回到普通模式。 使用c键配合其他按键进行删除然后进入插入模式的操作 c的作用是改变（change）字符/行/段落，类似于d，单独的c只是一个操作符（operator），需要根据实际的动作(motion)命令来产生效果。因此所有对d有效果的动作命令对c依然有效，只是动作从删除变为了改变（即删除然后进入插入模式）。例如 cw删除字符到下个词（change word）开头，并进入插入模式。 cj删除当前行及其下一行的所有字符（change j）。 cc删除当前行所有字符，并进入插入模式。 cG删除当前光标到全文的结尾的所有字符，并进入插入模式（change G）。 同时，类似于d的是，通过c删除的内容也会存储在数字寄存器内。 值得注意的是，类似于D单键等效于d$的功能，C单键等效于c$的功能。因此，可通过C键进行从当前光标删除到行尾，并进入插入模式的操作，减少操作次数。 使用s键删除单个字符并进入插入模式 如果说c对应d+进入插入模式的话，s应该就是对应x+进入插入模式了。前者要进入插入模式插入文字，后者依旧保持普通模式，不进行文字插入。因此 dl删除当前光标右边的字符，即删除当前光标的字符（delete l），等效于x。 cl删除当前光标右边的字符并进入插入模式，即改变当前光标的字符（change l），等效于s。 使用i 键在当前字符前进入插入模式。 使用a 键在当前字符后进入插入模式。 i和a是最常用的进入插入模式插入文本的方法，注意i和a并不是操作符，因此并不能搭配动作指令，它们的指令效果是立刻生效的。 值得注意的是，类似于D单键等效于d$的功能，A单键等效于$a（注意a不是操作符，因此不能使用a$）的功能。因此，可通过A键进行从当前光标跳转到行尾，并在行尾后进入插入模式的操作，减少操作次数。 类似的，I单键等效于^i（注意i不是操作符，因此不能使用i^）的功能。因此，可通过I键进行从当前光标跳转到行首（非空格），并在行首前进入插入模式的操作，减少操作次数。 简而言之，通过i和a进行当前光标字符前插入和字符后插入，通过I和A进行行首插入和行末插入。 使用o 键新建空白行并进入插入模式。 o的作用是在当前光标下新建空白行并进入插入模式。O则是在上一行插入。 o的新建一行操作在当前光标之下。 O的新建一行操作在当前光标之上。 数字操作 普通模式的命令进入插入模式时仍可以通过数字进行重复。以之前的一些命令为例 cw删除字符到下个词（change word）开头，并进入插入模式；而c2w会删除到下2个词（change 2 word）开头，并进入插入模式。 a 在当前字符后进入插入模式。 而2a会进入插入模式，并在退回普通模式时插入2次内容。 o的新建一行操作在当前光标之下。而3o会进入插入模式，并在退回普通模式时候插入3行内容。 小结3( uppercase ) vim的模式有普通模式和插入模式。基础操作模式可以分为几种。 特殊操作 z组合操作窗口调整（zz，zt，zb） %匹配跳转 跳转动作（动作命令）+数字（可不加）： h，j，k，l，跳转单个字符 w，b，e，跳转单个词（W，B，E类似） $，0，^，跳转行首行末 f，t，查找字符跳转；;，,，重复查找 gg，G，全文跳转 *，#，搜索词跳转；n，N，重复搜索 单字符+数字（可不加）操作 x删除单个字符，r替代单个字符，s删除单个字符并进入插入模式 ~单个字符大小写转换 i和a进入插入模式（字符前/后） 数字+操作符+动作命令 或 操作符+数字+动作命令 d删除操作符，配合动作命令（2中的任何动作）以及数字完成多次删除 y复制操作符，配合动作命令（2中的任何动作）以及数字完成多次复制 c改变操作符，配合动作命令（2中的任何动作）以及数字完成多次改变（即删除+进入插入模式） 大写按键需要注意的是，有些大写按键等效于操作符+首尾动作命令的操作，有些则是反向操作： 小写按键 意义 大写按键 意义 w b e 字跳转 W B E 字跳转（带标点、空格） x 向后删除单字符 X 向前删除单字符 r 替换单字符 R 替换多个字符 f t 查找跳转 F T 反向查找跳转 p 粘贴在光标后 P 粘贴在光标前 i a 进入插入模式 I A 行首/行尾进入插入模式 o 下方新建行 O 上方新建行 d 删除操作符 D 等效d$，删除到行尾 y 复制操作符 Y 等效y$，复制到行尾 等效yy，复制当前行 c 改变操作符 C 等效c$，改变到行尾 上表也不需要记忆，在实际使用的时候会自然形成习惯，即用了小写的按键，自然会考虑大写按键的类似操作。 Level12（(,),&#123;,&#125;,[,],object,.） 使用(和)进行句子跳转的操作 句子跳转操作包括(和)。句子按照标点句号.，问号?以及感叹号!作为结尾标识。 (的作用是向前跳转到上一句(首个非空字符)。 )的作用是向后跳转到下一句(首个非空字符)。 同样的，(，)也是动作命令，也可以结合d、y、c等操作符来操作。同样的，此操作仍可以通过数字进行重复。因此 d3)向后删除3句话（delete 3 sentence forward）。 y2( 向前复制2句话（yank 2 sentence backward）。 使用&#123;和&#125;进行段落跳转的操作 段落跳转操作包括&#123;和&#125;。段落按照空行作为分隔标识。 &#123;的作用是向前跳转到上一段落。 &#125;的作用是向后跳转到下一段落。 &#123;，&#125;也是动作命令，也可以结合d、y、c等操作符来操作。同样的，此操作仍可以通过数字进行重复。与前述按句子操作类似，在此不赘述。 使用[]配合其他括号，包括[&#123;,&#125;]，[(，)]，[[，]]，进行查找未闭合括号跳转的操作 每一对括号在代码中应该是匹配的，通过[]搜索未闭合括号的的操作可以方便查询代码结构。 [的作用是向前匹配到上一个未闭合括号（括号为&#123;，(，[）。 ]的作用是向后跳转到下一个未闭合括号（括号为&#125;，)，]）。 object对象操作。i，inner object，a，an object 对象，需配合操作符使用 普通的操作符+动作命令的操作对象均是由按键决定的，比如词（w,b,e），首尾（0，^，$），搜索位置（f,t）等，但有时实际的操作对象可能要求要更精确一些。 在小结3中总结过通过操作符（d，y，c）配合动作命令和数字进行批量修改，但有时动作命令可能无法满足操作复杂度的要求。因此vim引入了对象（object）的概念。以w为例，w本身是动作命令，会使光标跳转到下个词（word）开头。 而配合动作命令则可以得到dw删除字符到下个词（delete word）开头。 假设现在的操作光标在词的中间位置，则dw无法进行完整的删除，如下图所示。 这时若将整个词（word）作为对象（object）进行处理，采用daw（delete an object word），则可以直接删除掉整个词。 常见的对象（object）包括括号（&#123;&#125;,(),[]），引号（''，&quot;&quot;），word（w），sentence(s)，paragraph（p）等。 a和i的区别在于是否包括对象本身（边缘）。下面部分演示使用未提及的可视模式（Visual Mode）来展示对象（object）选择功能。 .重复 .的作用是重复（repeat）最近一次进行的修改。修改内容可以是删除(d)，也可以是改变(c)，小结3中的操作符+数字+动作命令均可通过.进行重复。.操作与配合数字操作不同的是，.的操作效果更直观，且数量控制更精确，通常.操作会配合u（undo）撤销操作一起，即重复多了就撤销，不需要在意具体的重复次数。下面演示几个简单功能来说明.操作。 重复删除行，重复粘贴 重复改变词 重复行尾添加分号; Level13（null） 13在国外不吉利，没有这关 Level14（u,&lt;C-r&gt;,H,L,M,|,:count,/,?,m,`,'） u撤销 &lt;C-r&gt;取消撤销 u的作用是撤销（undo）最近一次进行的修改。而&lt;C-r&gt;的作用是重做（redo）撤销的操作。类似Windows中的通用命令&lt;C-z&gt;撤销和&lt;C-y&gt;重做。 使用H L M移动光标 使用:&lt;count&gt;&lt;CR&gt;进行行跳转 使用&lt;count&gt;|进行列跳转 以上几个命令除了:&lt;count&gt;&lt;CR&gt;平时使用较少，适合于进行某些需要精确行列号跳转的场景。 H的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的首行（High）。 L的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的尾行（Low）。 M的作用是在不滚动屏幕的状态下，将光标移动至当前屏幕显示的中间行（Middle）。 :&lt;count&gt;&lt;CR&gt;的count输入任意数字可以跳转到对应行，其功能类似于&lt;count&gt;G。 &lt;count&gt;|的count输入任意数字可以跳转到对应列。 使用/&lt;word&gt;&lt;CR&gt; 键全文搜索名称为&lt;word&gt;的词并跳转至第一个词（正向），同时高亮所有匹配的词。 使用?&lt;word&gt;&lt;CR&gt; 键全文搜索名称为&lt;word&gt;的词并跳转至第一个词（反向），同时高亮所有匹配的词。 /和?的搜索方式与*和#类似，因此依然可以使用n和N重复搜索跳转的操作。 使用m键在指定的位置设置标记。 使用`跳转到制定的标记位置。 使用'跳转到指定的标记位置的第一个非空字符。 m的作用是标记位置（mark），例如命令 ma (mark a)表示用 a 标记当前的光标位置。可以通过输入:mark&lt;CR&gt;来查看当前的使用的所有mark标记。 标记包括每个缓冲区的局部标记和全局标记。局部标记可使用a-z的所有小写字母标记，而全局标记可使用A-Z的所有-大写字母标记。简单来说，局部标记可在当前文件前后跳转，全局标记可在文件间跳转。标记完成后可通过`跳转到制定的标记位置，或通过'跳转到指定的标记位置的第一个非空字符。 补：可视模式演示 本游戏vim-adventure缺少了一个重要部分，即可视模式(Visual Mode)。 v 普通可视模式 V行可视模式 &lt;C-v&gt;(Linux or MAC)或&lt;C-q&gt;（Windows专用）列可视模式 可视模式的操作逻辑类似鼠标点选后修改，不过具体到vim上与其他编辑器略有不同（比如列操作时不会对所有行进行同时显示，只有退出可视模式后才会统一弹出）。这里只演示功能，不进行具体功能介绍，。 结语 本教程仅供入门，关于vim使用相关知识最全面的首推Drew Neil的Practical Vim一书，针对普通模式、插入模式、可视模式及命令行模式等多种模式、多种操作方式均有详细的技巧教程。当然因为书本身只针对vim的技术点，因此关于vim配置vimrc的相关知识就相对少一些，不过相信读完全书后每位读者都会有自己的认知和配置要求，就能自己动手开始定制自己的vim了。 完结撒花~2020/7/7","categories":[{"name":"editor","slug":"editor","permalink":"https://blog.honk.wang/categories/editor/"}],"tags":[{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"}]},{"title":"Hexo博客搭建","slug":"hexo/hexo博客搭建","date":"2020-05-17T14:14:13.000Z","updated":"2020-11-02T15:57:02.146Z","comments":true,"path":"posts/Hexo-Blog-Construction/","link":"","permalink":"https://blog.honk.wang/posts/Hexo-Blog-Construction/","excerpt":"","text":"本文旨在列举博客搭建的所有参考资料来源。 PS：本人不会网页前端，所有来源均参考各位博客大佬及网络资源。 框架 入门 博主之前刚开始接触hexo时用的yilia主题，小歪的教程。 教你免费搭建个人博客，Hexo&amp;Github | 小歪的博客 文档 | Hexo 主题 butterfly🦋yiliareplica本站使用的主题butterfly，作者JerryC，基于hexo-theme-melod升级。 Butterfly - A Simple and Card UI Design theme for Hexo jerryc127/hexo-theme-butterfly: 🦋 A Hexo Theme: Butterfly JerryC - 今日事,今日畢 小歪教程使用的主题yilia，作者已停更多年。 litten/hexo-theme-yilia: 一个简洁优雅的hexo主题 A simple and elegant theme for hexo Litten的博客 GitHub风格的博客主题。 sabrinaluo/hexo-theme-replica: Github style replication for hexo theme 小白妹妹写代码 优化 美化全优化双部署SSL首推超逸的博客，详细且很照顾新手，本人也很有意思。 【源码开放】Hexo+Github 博客butterfly 和 matery 主题 搭建完全教程【整理】 | 超逸の博客 HCLonely大佬的一揽子美化教程也很好，包括访客地图、文章日历、投票系统、加载动画（新版butterfly已自带）、页脚跳动的❤、页脚显示网站运行时间、双评论系统、随机文章跳转、文章统计图等。 Hexo博客美化 | HCLonely Blog 小康的方法主要通过链接css和js进行美化，不用修改模板，很方便。另外可以辅以乐特的文章，自行修改。 Hexo博客之butterfly主题优雅魔改系列（持续更新） | 小康博客 Butterfly(蝴蝶)主题美化、优化、无修改源码 (持续更新中…) | Lete乐特 's Blog 各种一揽子优化教程，包括图片加载、代码压缩、全站CDN加速、SEO、URL永久链接以及其他一些小技巧，不一一细说，自行查阅。 Hexo进阶之各种优化 | Sky03’s Blog 使用Jsdelivr/CDN加速博客访问速度 | 过客~励む GitHub+Coding双线部署。主要是注意域名解析出问题的时候证书生成会有问题，暂停解析一下就好。（最新已改为部署至Vercel） Hexo：将你的博客部署到 Vercel | Serok’s Blog 2019hexo博客部署到coding该绕的坑-奥怪的小栈 - 奥怪 - 博客园 hexo干货系列：（四）将hexo博客同时托管到github和coding - 简书 Coding Pages 申请 SSL 证书错误：urn:acme:error:unauthorized: Invalid response from http://xxxxx/_网络_TRHX’S BLOG-CSDN博客 升级https。 为自定义域名的Hexo博客升级到Https网站_网络_qq_37683287的博客-CSDN博客 SSL 证书 腾讯云实现全站 HTTPS 方案 - 产品简介 - 文档中心 - 腾讯云 功能 以下的是一些其他的附加功能，可按需添加。 hexo插件小功能卡通-Live2D 向你的Hexo里放上一只萌萌哒二次元看板娘! EYHN/hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo! Hexo博客yilia主题首页添加helper-live2d模型插件 - 简书 统计-hexo-chart 懒人大佬将matery主题中的文章发布统计图、标签统计图、文章分类统计图做成了插件。 HCLonely/hexo-charts: Render hexo posts, categories, and tags into charts. hexo-charts插件Demo | HCLonely Blog [Demo] 音乐-hexo-tag-aplayer 主题自带js和css，但仍需安装插件 MoePlayer/hexo-tag-aplayer: Embed aplayer in Hexo posts/pages 链接-hexo-abbrlink hexo的页面地址转换为永久链接，有效简化地址长度。 rozbo/hexo-abbrlink: create one and only link for every post for hexo hexo+yilia添加URL持久化 | 荷塘月色的博客 加密-hexo-blog-encrypt 你可能需要写一些私密的博客，通过密码验证的方式让人不能随意浏览。 hexo-blog-encrypt/ReadMe.zh.md at master · MikeCoder/hexo-blog-encrypt 备份-hexo-git-backup 备份hexo博客源文件，建议private。 Hexo 常用插件 | XJHui’s Blog coneycode/hexo-git-backup: you can use it to backup your blog into git. 置顶-hexo-generator-index-pin-top 文章置顶，主题自带支持，安装插件即可。 netcan/hexo-generator-index-pin-top: Index generator plugin for Hexo. Pin top version Butterfly 安裝文檔(三) 主題配置-1 | Butterfly 外链-hexo-filter-nofollow 自动为 Hexo 博客中的外链添加rel=&quot;external nofollow noreferrer&quot; 的插件,从而改善你的网站的安全性和 SEO。 hexo-filter-nofollow - Hexo 官方的 nofollow 插件 | Sukka’s Blog hexojs/hexo-filter-nofollow: Add nofollow attribute to all external links automatically. 访客地图-Clustrmaps 访客地图用于统计访客来源。 hexo(butterfly)加入clustrmaps访问者地图_定位,html,javascript_cungudafa的博客-CSDN博客 Free Website Counter Showing Visitor Location on Map 评论系统-Valine 注意各位大佬的Valine-Admin的模板不一样，配置的环境变量也不同。只能选择一个部署，自行选择。 Valine Admin 邮件回复提醒 | Xuexi’s Blog Valine添加博主标签及评论微信、QQ通知 | HCLonely Blog Valine评论之Valine-admin配置攻略 | 小康博客 Valine添加自定义表情 | 小康博客 优雅解决LeanCloud流控问题 | 小康博客 Valine 一款快速、简洁且高效的无后端评论系统。 LeanCloud 说说-Artitalk 说说界面，发布心情、吐槽。 Artitalk.js 时间线-Timeline 发布建站历史的时间轴。 Responsive Vertical Timeline | CodyHouse 版本徽章-Badges 项目版本的徽章标志。已从shields.io换为badgen。 GitHub 项目徽章的添加和设置 - LPD-iOS Shields.io: Quality metadata badges for open source projects Badgen - Fast badge generating service 名言生成-诗词&一言 自动生成一句话的API接口，可以在butterfly中配置副标题source为下面的接口，也可以放在网站或文章任意位置。 为你的博客引入——今日诗词、每日一言（js插件分享） | cungudafa Hitokoto - 一言 今日诗词 - 一言API - 诗词实时智能推荐 - 今日诗词开放接口 - 今日诗词 API 图床-PicGo+CDN 方案很多，用腾讯/阿里云自己搭、白嫖jsDelivr等，自行选择。 github做Markdown图床 - 简书 Hexo 博客图片添加至图床—腾讯云COS图床使用。 使用PicGo+Github搭建免费图床 | 过客~励む Github+PicGo+cdn配置私人图床（丝滑操作撰写md文章） | cungudafa 简历-nimo-markdown-cv 使用wodeni的模板生成一个html文件即可。 wodeni/nimo-markdown-cv: Maintain your CV in Markdown Hexo博客添加自定义HTML页面_javascript_本该如此-CSDN博客 导航-WebstackPage 需要后台，使用WordPress、Laravel或者Typecho等均可。 WebStackPage/WebStackPage.github.io: ❤️静态响应式网址导航网站 - webstack.cc WordPress 版 WebStack 导航主题使用说明，更新于20200115 | 一为忆 Windows 系统本地安装 WordPress 博客的方法 - SHTION｜时讯联科 hui-ho/WebStack-Laravel: 一个开源的网址导航网站项目，您可以拿来制作自己的网址导航。 typecho使用WebStack搭建网址导航 - 游轶的小站 设计-Canva&Logosc 进行Banner和Logo等图标设计。 Canva在线平面设计软件_免费设计模板素材和海量正版图片 - Canva中文官网 LOGO设计神器！人工智能为您在线设计LOGO，设计名片，打造完整企业VI 手机-Termux 使用移动设备进行hexo博客的编写 如何在移动设备上进行 Hexo 博客编辑和部署 | 艾迪的小栈 致谢 搭博客的过程就是参考一个大佬，然后发现另一个大佬的大佬，然后发现更多的大佬。 首先感谢主题butterfly的原作者JerryC，做了一个非常适合新手的hexo主题。 其余各位大佬的链接均在友链界面，在此一并感谢，帮助了本人很多。","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://blog.honk.wang/tags/blog/"}]},{"title":"Gvim-Verilog-Final","slug":"IC/editor/Gvim-Verilog-Final","date":"2020-05-13T15:13:50.000Z","updated":"2020-10-31T11:25:55.507Z","comments":true,"path":"posts/Gvim-Verilog-Final/","link":"","permalink":"https://blog.honk.wang/posts/Gvim-Verilog-Final/","excerpt":"","text":"此篇为终篇，介绍所有安装好的定制功能。 开始之前先看个有趣的。据说各编辑器的学习难度是这样的。 本文延续上两篇的内容。 初篇|环境配置（几乎所有参考的插件和脚本在此篇） 中篇|使用手册（部分功能的使用说明） 与之前篇的不同？ 将verilog相关的内容从vimrc配置文件全部移动到了automatic.vim文件中 添加emacs verilog-mode的调用快捷键 根据自己习惯调整了菜单栏和工具栏的一些结构，重新定义了快捷键方便自己操作（比如header和al改为了;header和;al） 新增ASCII画部分功能 下面演示部分Gvim写Verilog功能。 PS：快捷键单独配置，只针对博主自用版的Gvim有效。 Wave Gvim中添加&amp;调整时序波形 参考中篇|使用手册。波形的起始位置、时钟间隔空格长度、时钟偏移及上升沿或下降沿触发等均可在脚本中自行配置。 快捷键： &lt;C-F8&gt;翻转波形 Code Generate 代码段快速生成，包括头部信息，always块，单行多行注释，状态机，当前时间等，可以通过快捷键或者直接点击的方式生成代码。 鼠标点击的方式参考中篇|使用手册。 快捷键： header和al快捷键已经改为带Leader的;header和;al，主要为了不影响h和a键的操作速度。头部的作者、芯片、网站等信息在_vimrc中配置 状态机的fsm快捷键暂时删除，现在有更新的自动生成方法 &lt;F2&gt;添加单行注释，&lt;F3&gt;选中区域添加多行注释，&lt;F4&gt;行末添加注释 插入模式下使用&lt;F2&gt;插入当前时间 Load Template 每次在代码里添加新模板太麻烦了，可以直接导入整个写好的.v文件作为模板 快捷键： 输入:LoadTemplate后输入数字选择.v文件的模板即可，模板可自行编写 New 新建.v文件自动套用模板 Auto Update 写入文件时修改时间自动更新 Multi Channel 多通道批量命名 参考中篇|使用手册，功能源自vim插件VisIncr。 快捷键： 列可视模式选定后输入:I&lt;CR&gt;（递增）或:I -1&lt;CR&gt;（递减） Declaration 进行端口和寄存器等的声明并自动对齐 参考中篇|使用手册和初篇|环境配置，功能源自快捷键的对齐操作。 快捷键： ;di产生input信号声明，;dow产生output wire 信号声明，;dor产生output reg信号声明（注意声明时不能带位宽，不然会被截位。） F7对齐输入输出端口的格式；F8对齐reg/wire的格式；通过快捷键F6调整例化模块的端口对齐 Align 一键自动对齐所有格式（包括输入输出端口、注释位置、always块、assign块等）。 特殊原因，暂缓。 Auto automaic.vim插件本身包含的自动化功能包含自动例化(Autoinst)，自动例化端口更新（AutoinstUpdate），自动例化端口顺序更新（AutoinstUpdateOrder），自动例化模块信号对齐(AutoPortReAlign)，自动例化端口添加输入or输出的注释(AutoinstPortDirectionToInst)，自动定义wire和reg(AutoDef)，自动定义端口连接线(AutoArg) Emacs的verilog-mode插件的自动化功能包括自动例化(AutoInst)，自动wire(AautoWire)，自动reg(AutoReg)，自动例化参数(AutoParam) 只展示自动例化和自动添加参数。 有关automatic.vim参考vim auto script for verilog &amp; RtlTree - (like Emacs, Verdi) - FPGA/ASIC资料共享 - EETOP 创芯网论坛 -。 有关Emacs的verilog-mode 参考ExASIC: RTL顶层自动连线的秘武器：Emacs verilog-mode介绍以及如何高效的编写Verilog—终极版 Gvim自动化插件分享_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili 快捷键： 自动例化：插入/*autoinst*/后使用&lt;S-F3&gt; 自动生成所有wire/reg：插入/*autodef*/后使用&lt;S-F2&gt; 自动例化parameter：插入/*autoinstparam*/后使用:EmacsAuto&lt;CR&gt;调用Emacs的verilog-mode即可 其余不常用，自行菜单栏调用 Jump Rtl树，搜索module/instance，进/出子模块，搜索驱动信号 类似Verdi的跳转功能，Rtl树生成参考中篇|使用手册，功能仍然参考vim auto script for verilog &amp; RtlTree - (like Emacs, Verdi)。 Syntax 语法检查，快速跳转错误位置 参考中篇|使用手册，功能源自vim插件SyntasticCheck，另需要外置iverilog作为Linter。 快捷键： :SyntasticCheck&lt;CR&gt; Ascii （2020/8/16更新）最近发现了ASCII画，稍微研究了一下。主要有表格、图像和字符画这几个。 Table 快速生成ASCII表格，快捷调整表头、表格位置。 参考stormherz/tablify。功能源自vim插件tablify。 快捷键： 可视模式下选中编辑好的文本后\\tl or \\tt 生成表格（左对齐），\\tc 生成表格（居中对齐），\\tr 生成表格（右对齐） \\tu还原已转换的表格 \\tS已转换的表格按当前列排序（数字或字母顺序） \\tRL重新右对齐当前行，\\tRR重新左对齐当前行，\\tRC重新居中对齐当前行 \\tK当前行上移\\tJ当前行下移 \\tL当前列左移 \\tH 当前列右移 DrawIt 画带箭头的ASCII结构图 参考vim-scripts/DrawIt以及How To Create ASCII Drawings in Vim Editor。功能源自vim插件DrawIt。 \\di开启DrawIt，\\ds关闭DraIt。开启后直接移动方向键&lt;Up&gt;，&lt;Down&gt;，&lt;Right&gt;，&lt;Left&gt;即可画线 通过&gt;，&lt;，v，^画箭头，通过\\&gt;，\\&lt;，\\V，\\^画大箭头。\\b绘制长方形盒，\\e绘制椭圆 其余快捷键过多，见参考链接 Text2ASCII 通过Text to ASCII Art Generator (TAAG)直接生成即可。 比如我的名字HonkW： 123456&#x2F;&#x2F; _ _ _ __ __&#x2F;&#x2F; | | | | | | \\ \\ &#x2F; &#x2F;&#x2F;&#x2F; | |__| | ___ _ __ | | _\\ \\ &#x2F;\\ &#x2F; &#x2F; &#x2F;&#x2F; | __ |&#x2F; _ \\| &#39;_ \\| |&#x2F; &#x2F;\\ \\&#x2F; \\&#x2F; &#x2F; &#x2F;&#x2F; | | | | (_) | | | | &lt; \\ &#x2F;\\ &#x2F; &#x2F;&#x2F; |_| |_|\\___&#x2F;|_| |_|_|\\_\\ \\&#x2F; \\&#x2F; Summary Gvim的折腾到此为止，基本整合完之前看到的所有内容。 如果有推荐或新发现的插件或脚本，会在这篇文章中额外添加。感谢阅读。","categories":[{"name":"editor","slug":"editor","permalink":"https://blog.honk.wang/categories/editor/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"}]},{"title":"Cordic Algorithm","slug":"IC/math/Cordic算法","date":"2020-03-24T14:56:47.000Z","updated":"2020-10-31T11:42:39.728Z","comments":true,"path":"posts/Cordic-Algorithm/","link":"","permalink":"https://blog.honk.wang/posts/Cordic-Algorithm/","excerpt":"","text":"公式渲染引擎由Mathjax换为Katex,文章可能存在渲染问题，如有发现问题请留言。 前世今生 以下源自参考资料[6]：CORDIC技术并不是什么新鲜的东西。事实上它可以追溯到1957年由J.Volder发表的一篇文章。在上个世纪五十年代，在大型实际的计算机中的实行移位相加受到了当时技术上的限制，所以使用CORDIC变得非常必要。到了七十年代，Hewlett Packard和其他公司出产了手持计算器,许多计算器使用一个内部CORDIC单元来计算所有的三角函数(了解这件事的人们一定还记得，那时求一个角度的正切值需要延迟大约1秒中)。二十世纪八十年代，随着高速度乘法器与带有大存储量的通用处理器的出现，CORDIC算法变得无关紧要了。然而在二十一世纪的今天，对于FPGA来说，CORDIC一定是在DSP应用中(诸如多输入多输出（MIMO）,波束形成以及其他自适应系统)计算三角函数的备选技术。 本文将详细介绍CORDIC算法，所有参考资料见文章尾部。 Cordic详解 圆周坐标系 从坐标旋转开始 如下图，一个直角坐标点(x1,y1)(x_1,y_1)(x1​,y1​)逆时针旋转θθθ角度到点(x2,y2)(x_2,y_2)(x2​,y2​)，如何计算(x2,y2)(x_2,y_2)(x2​,y2​)呢？ 公式如下： x2=x1cosθ−y1cosθy2=x1sinθ+y1cosθx_2 = x_1cosθ-y_1cosθ \\\\ y_2 = x_1sinθ+y_1cosθ x2​=x1​cosθ−y1​cosθy2​=x1​sinθ+y1​cosθ 其实只需要一点高中的知识就能推导这个公式了。 假设底角为ααα，旋转半径为111，则 x2=cos(α+θ)=cos(α)cos(θ)−sin(α)sin(θ)=x1cosθ−y1cosθy2=sin(α+θ)=sin(α)cos(θ)+cos(α)sin(θ)=x1sinθ+y1cosθx_2=cos(α+θ) = cos(α)cos(θ) - sin(α)sin(θ) =x_1cosθ-y_1cosθ \\\\ y_2=sin(α+θ) = sin(α)cos(θ) + cos(α)sin(θ) =x_1sinθ+y_1cosθ x2​=cos(α+θ)=cos(α)cos(θ)−sin(α)sin(θ)=x1​cosθ−y1​cosθy2​=sin(α+θ)=sin(α)cos(θ)+cos(α)sin(θ)=x1​sinθ+y1​cosθ 上面的公式也可以写成矩阵的形式，即 [x2y2]=[cosθ−sinθsinθcosθ][x1y1]\\left[ \\begin{matrix} x_2\\\\ y_2 \\end{matrix} \\right] = \\left[ \\begin{matrix} cosθ&amp;-sinθ\\\\ sinθ&amp;cosθ \\end{matrix} \\right] \\left[ \\begin{matrix} x_1\\\\ y_1 \\end{matrix} \\right] [x2​y2​​]=[cosθsinθ​−sinθcosθ​][x1​y1​​] 以上公式对应逆时针旋转。若是顺时针旋转，则公式应为 [x1y1]=[cosθsinθ−sinθcosθ][x2y2]\\left[ \\begin{matrix} x_1\\\\ y_1 \\end{matrix} \\right] = \\left[ \\begin{matrix} cosθ&amp;sinθ\\\\ -sinθ&amp;cosθ \\end{matrix} \\right] \\left[ \\begin{matrix} x_2\\\\ y_2 \\end{matrix} \\right] [x1​y1​​]=[cosθ−sinθ​sinθcosθ​][x2​y2​​] 那么已知旋转角θθθ，如何通过FPGA来计算x2x_2x2​和y2y_2y2​呢？答案就是反复迭代。 二分角度旋转 假设(x1,y1)=(100,200)(x_1,y_1)=(100,200)(x1​,y1​)=(100,200)，要求其极坐标系下的坐标(ρ,θ)(ρ,θ)(ρ,θ)。当然，求θθθ的过程也就是求arctan(y/x)arctan(y/x)arctan(y/x)的过程。首先通过计算器得到结果(ρ,θ)=(223.61,63.435)(ρ,θ) = (223.61,63.435)(ρ,θ)=(223.61,63.435)。下面计算先只关注θθθ的旋转变化，不关注ρρρ的长度变化。这时最直观简单的想法就是先旋转一个角度进行一次尝试。 已知角度在(0°,90°)(0°,90°)(0°,90°)这个范围内，借鉴二分法的思想，先顺时针旋转45°45°45°进行尝试。根据之前推导的公式可知 [xy]=[cos(45°)sin(45°)−sin(45°)cos(45°)][100200]=[212.1370.711]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(45°)&amp;sin(45°)\\\\ -sin(45°)&amp;cos(45°) \\end{matrix} \\right] \\left[ \\begin{matrix} 100\\\\ 200 \\end{matrix} \\right] = \\left[ \\begin{matrix} 212.13\\\\ 70.711 \\end{matrix} \\right] [xy​]=[cos(45°)−sin(45°)​sin(45°)cos(45°)​][100200​]=[212.1370.711​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转的角度不够，则在此基础上继续顺时针旋转45/2=22.5°45/2=22.5°45/2=22.5°，此时角度为45+22.5=67.5°45+22.5=67.5°45+22.5=67.5°。根据推导的公式可知 [xy]=[cos(22.5°)sin(22.5°)−sin(22.5°)cos(22.5°)][212.1370.711]=[223.04−15.85]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(22.5°)&amp;sin(22.5°)\\\\ -sin(22.5°)&amp;cos(22.5°) \\end{matrix} \\right] \\left[ \\begin{matrix} 212.13\\\\ 70.711 \\end{matrix} \\right] = \\left[ \\begin{matrix} 223.04\\\\ -15.85 \\end{matrix} \\right] [xy​]=[cos(22.5°)−sin(22.5°)​sin(22.5°)cos(22.5°)​][212.1370.711​]=[223.04−15.85​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度超过了范围，则在此基础上逆时针回转22.5/2=11.25°22.5/2=11.25°22.5/2=11.25°，此时角度为45+22.5−11.25=56.25°45+22.5-11.25=56.25°45+22.5−11.25=56.25°。根据推导的公式可知 [xy]=[cos(11.25°)−sin(11.25°)sin(11.25°)cos(11.25°)][223.04−15.85]=[221.8527.967]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(11.25°)&amp;-sin(11.25°)\\\\ sin(11.25°)&amp;cos(11.25°) \\end{matrix} \\right] \\left[ \\begin{matrix} 223.04\\\\ -15.85 \\end{matrix} \\right] = \\left[ \\begin{matrix} 221.85\\\\ 27.967 \\end{matrix} \\right] [xy​]=[cos(11.25°)sin(11.25°)​−sin(11.25°)cos(11.25°)​][223.04−15.85​]=[221.8527.967​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转的角度又不够，则此基础上继续顺时针旋转11.25/2=5.625°11.25/2=5.625°11.25/2=5.625°，此时角度为45+22.5−11.25+5.625=61.875°45+22.5-11.25+5.625=61.875°45+22.5−11.25+5.625=61.875°。根据推导的公式可知 [xy]=[cos(5.625°)sin(5.625°)−sin(5.625°)cos(5.625°)][221.8527.967]=[223.526.0874]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(5.625°)&amp;sin(5.625°)\\\\ -sin(5.625°)&amp;cos(5.625°) \\end{matrix} \\right] \\left[ \\begin{matrix} 221.85\\\\ 27.967 \\end{matrix} \\right] = \\left[ \\begin{matrix} 223.52\\\\ 6.0874 \\end{matrix} \\right] [xy​]=[cos(5.625°)−sin(5.625°)​sin(5.625°)cos(5.625°)​][221.8527.967​]=[223.526.0874​] 这时纵坐标已经比较接近000了。按照这个模式继续算下去，可以不断逼近真实的结果。比如现在的结果范围为(ρ,θ)=(223.52,61.875±5.625)(ρ,θ)=(223.52,61.875±5.625)(ρ,θ)=(223.52,61.875±5.625)，已经接近实际结果(ρ,θ)=(223.61,63.435)(ρ,θ)=(223.61,63.435)(ρ,θ)=(223.61,63.435)了。旋转过程演示图如下。 因此通过多次迭代，可以逐渐逼近结果。但是如何计算上面的cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)cos(45),sin(45),cos(22.5),sin(22.5),cos(11.25),sin(11.25)等值？其实如果仔细观察，这些点都是固定的，因此他们的cos()cos()cos()和sin()sin()sin()也是固定的，所以只需要把要用的点的sin()sin()sin()和cos()cos()cos()提前计算好存起来，用时查表即可。Python实现如下。 12345678910111213141516171819202122232425262728293031323334353637383940import mathimport numpy as npITERATION_TIMES = 64i = 0d = 45cos = [0] * ITERATION_TIMESsin = [0] * ITERATION_TIMESdegree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): cos[i] = np.cos(d*np.pi/180) sin[i] = np.sin(d*np.pi/180) degree[i] = d; d = d/2#迭代计算for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x * cos[i] + y * sin[i] y_n = y * cos[i] - x * sin[i] z = z + degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z) else: x_n = x * cos[i] - y * sin[i] y_n = y * cos[i] + x * sin[i] z = z - degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z)print(z) 经过不同迭代次数，得到不同的结果。迭代次数越高，精度自然就越高。 迭代次数 计算角度（实际结果63.43494882292201） 16 63.433685302734375 32 63.43494881177321 64 63.43494882292201 长度缩放旋转 二分角度旋转的计算存在一个问题：计算量巨大。可以发现每一次旋转变换都需要进行4次浮点乘法运算，对于FPGA来说这个运算量过大。改进的方法就是通过变换坐标旋转的公式。 每次的旋转公式可以总结为 [xi+1yi+1]=[cos(θi)disin(θi)−disin(θi)cos(θi)][xiyi]=cos(θi)[1ditan(θi)−ditan(θi)1][xiyi]zi+1={zi+θi,if yi&gt;0zi−θi,if yi≤0where di={+1,if yi&gt;0−1,if yi≤0 ,θi=45°2i\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(θ_i)&amp;d_isin(θ_i)\\\\ -d_isin(θ_i)&amp;cos(θ_i) \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = \\begin{cases} z_i + θ_i, &amp; \\text{if $y_i$&gt;0} \\\\ z_i - θ_i, &amp; \\text{if $y_i$≤0} \\end{cases} \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}\\ ,θ_i=\\frac{45°}{2^i} [xi+1​yi+1​​]=[cos(θi​)−di​sin(θi​)​di​sin(θi​)cos(θi​)​][xi​yi​​]=cos(θi​)[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]zi+1​={zi​+θi​,zi​−θi​,​if yi​&gt;0if yi​≤0​where di​={+1,−1,​if yi​&gt;0if yi​≤0​ ,θi​=2i45°​ 这样进行转换后可以将cos(θ)cos(θ)cos(θ)从矩阵运算中提取出来并省略掉。为什么可以将cos(θ)cos(θ)cos(θ)省略掉呢？ 因为现在的计算只求θθθ的值，即旋转角度变化，不关心ρρρ长度的变化，省略掉的cos(θ)cos(θ)cos(θ)只是在长度上进行了放缩，并不影响其旋转的角度。因此转换公式变为 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]where di={+1,if yi&gt;0−1,if yi≤0\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases} [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]where di​={+1,−1,​if yi​&gt;0if yi​≤0​ 这种旋转方式被称为伪旋转(Pseudo-Rotation)。这样乘法的个数就从每一次旋转变换的4次变为了两次，存查找表的值也只需要tan(45),tan(22.5)tan(45),tan(22.5)tan(45),tan(22.5)…这样的值，减少了一半。过程演示图如下。 由上方过程演示图对比可以看出，旋转向量的长度在增长，但其旋转角度变化保持与之前一致。Python实现如下。 1234567891011121314151617181920212223242526272829303132333435363738import mathimport numpy as npITERATION_TIMES = 64i = 0d = 45tan = [0] * ITERATION_TIMESdegree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): tan[i] = np.tan(d*np.pi/180) degree[i] = d; d = d/2#迭代计算for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x + y * tan[i] y_n = y - x * tan[i] z = z + degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z) else: x_n = x - y * tan[i] y_n = y + x * tan[i] z = z - degree[i] x = x_n y = y_n #print(&quot;rotate_angle=&quot;,degree[i],&quot;y=&quot;,y_n,&quot;z=&quot;,z)print(z) 结果与之前的二分角度旋转一致。 cordic旋转 经过了长度缩放的变换，算法成功将乘法运算减少了一半。那还能不能继续减少运算量呢？其实依旧可以从之前的长度缩放变换的转换公式入手。 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]where di={+1,if yi&gt;0−1,if yi≤0\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] where\\ d_i= \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases} [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]where di​={+1,−1,​if yi​&gt;0if yi​≤0​ 第一次旋转45°时，转换公式为 [xi+1yi+1]=[1tan(45)−tan(45)1][xiyi]=[11−11][xiyi]\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;tan(45)\\\\ -tan(45)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;1\\\\ -1&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] [xi+1​yi+1​​]=[1−tan(45)​tan(45)1​][xi​yi​​]=[1−1​11​][xi​yi​​] 可见此次转换其实不需要进行乘法运算，可以直接进行加减运算就可以得到结果。然而第二次旋转22.5°22.5°22.5°的时候，由于tan(22.5°)=0.4142135623731tan(22.5°)=0.4142135623731tan(22.5°)=0.4142135623731，这是一个不整的小数。因此需要复杂的乘法运算才能得到结果。 那有没有办法规避这种复杂乘法？当然是有的。注意一开始的二分法是通过对45°45°45°角进行二分得到了22.5°22.5°22.5°，但其实迭代旋转角度可以不选择22.5°22.5°22.5°，只要比45°45°45°角小就可以。假设选择tan(θ)=12tan(θ)=\\frac{1}{2}tan(θ)=21​的θθθ角（θ=26.565051177078°θ=26.565051177078°θ=26.565051177078°），则第二次旋转的公式变换为 [xi+1yi+1]=[1tan(26.565051177078°)−tan(26.565051177078°)1][xiyi]=[112−121][xiyi]\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;tan(26.565051177078°)\\\\ -tan(26.565051177078°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;\\frac{1}{2}\\\\ -\\frac{1}{2}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] [xi+1​yi+1​​]=[1−tan(26.565051177078°)​tan(26.565051177078°)1​][xi​yi​​]=[1−21​​21​1​][xi​yi​​] 同样的，每次选择tan(θ)=1,12,14tan(θ)=1,\\frac{1}{2},\\frac{1}{4}tan(θ)=1,21​,41​…依次类推，这样计算就在定点运算层面简化了。因为乘12\\frac{1}{2}21​的操作等于将数右移一位，乘14\\frac{1}{4}41​等于将数右移两位，以此类推。这样，复杂的乘法运算转化为了简单的移位和加减运算。通项转换公式变换为 [xi+1yi+1]=[1ditan(θi)−ditan(θi)1][xiyi]=[1di2i−di2i1][xiyi]zi+1={zi+θi,if yi&gt;0zi−θi,if yi≤0where di={+1,if yi&gt;0−1,if yi≤0 ,θi=arctan(12i)\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;\\frac{d_i}{2^i}\\\\ -\\frac{d_i}{2^i}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = \\begin{cases} z_i + θ_i, &amp; \\text{if $y_i$&gt;0} \\\\ z_i - θ_i, &amp; \\text{if $y_i$≤0} \\end{cases} \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}\\ ,θ_i=arctan(\\frac{1}{2^i}) [xi+1​yi+1​​]=[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]=[1−2idi​​​2idi​​1​][xi​yi​​]zi+1​={zi​+θi​,zi​−θi​,​if yi​&gt;0if yi​≤0​where di​={+1,−1,​if yi​&gt;0if yi​≤0​ ,θi​=arctan(2i1​) 同样的，可以将θ=arctan(12i)θ=arctan(\\frac{1}{2^i})θ=arctan(2i1​)的值预先计算出来存起来，用时查表就可以。 tan(θ) θ 1 45.0° 0.5 26.56505117707799° 0.25 14.036243467926477° 0.125 7.125016348901798° 0.0625 3.5763343749973515° ‭0.03125‬ 1.7899106082460694° ‭0.015625‬ 0.8951737102110744° … … 过程演示图如下。 由上方过程演示图对比可以看出，cordic变换向量的长度与长度缩放旋转的变化类似，而其旋转角度发生了根本性变化，使得横纵坐标的变化的小数更整。Python实现如下。 12345678910111213141516171819202122232425262728293031323334353637import mathimport numpy as npITERATION_TIMES = 64i = 0d = 1degree = [0] * ITERATION_TIMESx = 100y = 200x_n = 0y_n = 0z = 0#查找表for i in range(ITERATION_TIMES): degree[i] = math.atan(d) d = d/2#迭代计算d = 1for i in range(ITERATION_TIMES): if(y&gt;0): x_n = x + (y &gt;&gt; d) y_n = y - (x &gt;&gt; d) z = z + degree[i] x = x_n y = y_n else: x_n = x - (y &gt;&gt; d) y_n = y + (x &gt;&gt; d) z = z - degree[i] x = x_n y = y_n d = d &gt;&gt; 1 print(z*180/np.pi) 至此基本讲清了cordic算法的本质原理（在圆周坐标下）。接下来补充一些其他cordic算法的相关内容。 参数、模式与坐标系 伸缩因子Kn 上一节中只关注了角度θθθ的求解，并没有关注到长度ρρρ的求解。实际上，如果考虑长度变化的话，那么cordic旋转公式应还原为（也就是将省略掉的cos(θ)cos(θ)cos(θ)补回来）： [xi+1yi+1]=[cos(θi)disin(θi)−disin(θi)cos(θi)][xiyi]=cos(θi)[1ditan(θi)−ditan(θi)1][xiyi]=cos(θi)[1di2i−di2i1][xiyi]zi+1=zi+diθiwhere di={+1,if yi&gt;0−1,if yi≤0, θi=arctan(12i)\\left[ \\begin{matrix} x_{i+1}\\\\ y_{i+1} \\end{matrix} \\right] = \\left[ \\begin{matrix} cos(θ_i)&amp;d_isin(θ_i)\\\\ -d_isin(θ_i)&amp;cos(θ_i) \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;d_itan(θ_i)\\\\ -d_itan(θ_i)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] = cos(θ_i) \\left[ \\begin{matrix} 1&amp;\\frac{d_i}{2^i}\\\\ -\\frac{d_i}{2^i}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} x_i\\\\ y_i \\end{matrix} \\right] \\\\ z_{i+1} = z_i + d_iθ_i\\\\ \\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases},\\ θ_i = arctan(\\frac{1}{2^i}) [xi+1​yi+1​​]=[cos(θi​)−di​sin(θi​)​di​sin(θi​)cos(θi​)​][xi​yi​​]=cos(θi​)[1−di​tan(θi​)​di​tan(θi​)1​][xi​yi​​]=cos(θi​)[1−2idi​​​2idi​​1​][xi​yi​​]zi+1​=zi​+di​θi​where di​={+1,−1,​if yi​&gt;0if yi​≤0​, θi​=arctan(2i1​) 还原为方程组的形式： xi+1=cos(θi)(xi+diyitan(θi)=cos(θi)(xi+diyi2i)yi+1=cos(θi)(yi−dixitan(θi)=cos(θi)(yi−dixi2i)zi+1=zi+diθiwhere di={+1,if yi&gt;0−1,if yi≤0, θi=arctan(12i)x_{i+1} = cos(θ_i)(x_i+d_iy_itan(θ_i)=cos(θ_i)(x_i+d_i\\frac{y_i}{2^i})\\\\ y_{i+1} = cos(θ_i)(y_i-d_ix_itan(θ_i)=cos(θ_i)(y_i-d_i\\frac{x_i}{2^i})\\\\ z_{i+1} = z_i + d_iθ_i\\\\ where\\ d_i = \\begin{cases} +1, &amp; \\text{if $y_i$&gt;0} \\\\ -1, &amp; \\text{if $y_i$≤0} \\end{cases}, \\ θ_i = arctan(\\frac{1}{2^i})\\\\ xi+1​=cos(θi​)(xi​+di​yi​tan(θi​)=cos(θi​)(xi​+di​2iyi​​)yi+1​=cos(θi​)(yi​−di​xi​tan(θi​)=cos(θi​)(yi​−di​2ixi​​)zi+1​=zi​+di​θi​where di​={+1,−1,​if yi​&gt;0if yi​≤0​, θi​=arctan(2i1​) 假设进行64次迭代，则结果计算为 x64=∏n=063cos(θn)(xn+dyn2n)y64=∏n=063cos(θn)(yn−dxn2n)z64=z0+∑n=063dθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{64} = \\prod_{n=0}^{63}cos(θ_n)(x_n+d\\frac{y_n}{2^n})\\\\ y_{64} = \\prod_{n=0}^{63}cos(θ_n)(y_n-d\\frac{x_n}{2^n})\\\\ z_{64} = z_0 + \\sum_{n=0}^{63}dθ_n \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ x64​=n=0∏63​cos(θn​)(xn​+d2nyn​​)y64​=n=0∏63​cos(θn​)(yn​−d2nxn​​)z64​=z0​+n=0∑63​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 可以发现其实迭代过程的计算分为两部分，一部分是cordic的旋转变换，一部分是cordic的长度伸缩变换。 cordic长度伸缩变换： ∏n=063cos(θn)\\prod_{n=0}^{63}cos(θ_n) n=0∏63​cos(θn​) cordic旋转变换： ∏n=063(xn+dyn2n)∏n=063(yn−dxn2n)where{d=+1,if yn&gt;0d=−1,if yn≤0\\prod_{n=0}^{63}(x_n+d\\frac{y_n}{2^n})\\\\ \\prod_{n=0}^{63}(y_n-d\\frac{x_n}{2^n})\\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases} n=0∏63​(xn​+d2nyn​​)n=0∏63​(yn​−d2nxn​​)where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​ 由于在cordic旋转变换中，已知θn=arctan(12n)θ_n=arctan(\\frac{1}{2^n})θn​=arctan(2n1​)，因此长度伸缩变换可以变化为： ∏n=063(cos(θn))=∏n=063(11+tan2(θn))=∏n=063(11+(12n)2)\\prod_{n=0}^{63}(cos(θ_n))=\\prod_{n=0}^{63}(\\sqrt{\\frac{1}{1+tan^2(θ_n)}})=\\prod_{n=0}^{63}(\\sqrt{\\frac{1}{1+(\\frac{1}{2^n})^2}}) n=0∏63​(cos(θn​))=n=0∏63​(1+tan2(θn​)1​​)=n=0∏63​(1+(2n1​)21​​) 当n→∞n\\to∞n→∞，上面的式子是收敛的，当结束变换时，应当乘以收敛值的倒数以恢复长度变换带来的影响。恢复长度变换影响而乘的这个数就叫做伸缩因子KnK_nKn​，是一个固定常数。 Kn=lim⁡n→∞(∏0n(1+(12n)2))≈1.646761Kn≈0.6073K_n=\\lim_{n\\to∞}(\\prod_{0}^{n}(\\sqrt{1+(\\frac{1}{2^n})^2}))≈1.64676 \\\\ \\frac{1}{K_n}≈ 0.6073 Kn​=n→∞lim​(0∏n​(1+(2n1​)2​))≈1.64676Kn​1​≈0.6073 通过下表可见伸缩因子随迭代次数的变化 迭代次数 伸缩因子Kn 10 1.646759211139822 20 1.6467602581200669 50 1.6467602581210652 100 1.6467602581210652 可见伸缩因子随着迭代次数增加而变化越来越小，最终收敛。这样可以利用cordic旋转后通过乘以伸缩因子来保证长度变换也是正确的，从而求到长度ρρρ。最终的变换公式如下。 xn+1=Kn∏n=0n(xn+dyn2n)yn+1=Kn∏n=0n(yn−dxn2n)zn+1=z0+∑n=0ndθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n+d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n-d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 + \\sum_{n=0}^{n}dθ_n\\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​+d2nyn​​)yn+1​=Kn​n=0∏n​(yn​−d2nxn​​)zn+1​=z0​+n=0∑n​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 两种旋转模式 在圆周坐标系下的坐标旋转其实存在两个问题： 已知x1x_1x1​，y1y_1y1​，如何计算旋转角θθθ使得y=0y=0y=0？ 已知旋转角θθθ，x1x_1x1​，且y1=0y_1=0y1​=0，如何计算x2x_2x2​和y2y_2y2​？ 这是两个镜像问题，只是从两个方向来考虑。 通过不断进行cordic旋转变换逼近y=0y=0y=0的点（顺时针，逼近y=0y=0y=0点） 使结果纵坐标y→0y\\to0y→0的cordic旋转变换称为向量模式(vector mode)。 通过不断进行cordic旋转变换逼近旋转角θθθ（逆时针，逼近θ=0θ=0θ=0的点） 使结果角度θ→0θ\\to0θ→0的cordic旋转变换被称为旋转模式(rotation mode)。 圆周坐标的向量模式(vector mode)的公式为（上一节已经推导） 迭代式： {xi+1=xi+diyi2iyi+1=yi−dixi2izi+1=zi+dθiwhere{di=+1,if yi&gt;0di=−1,if yi≤0,θi=arctan(12i)\\begin{cases} x_{i+1} = x_i+d_i\\frac{y_i}{2^i}\\\\ y_{i+1} = y_i-d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i + dθ_i\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $y_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $y_i$≤0} \\end{cases},θ_i = arctan(\\frac{1}{2^i})\\\\ ⎩⎪⎨⎪⎧​xi+1​=xi​+di​2iyi​​yi+1​=yi​−di​2ixi​​zi+1​=zi​+dθi​​where{di​=+1,di​=−1,​if yi​&gt;0if yi​≤0​,θi​=arctan(2i1​) 结果式： xn+1=Kn∏n=0n(xn+dyn2n)yn+1=Kn∏n=0n(yn−dxn2n)zn+1=z0+∑n=0ndθnwhere{d=+1,if yn&gt;0d=−1,if yn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n+d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n-d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 + \\sum_{n=0}^{n}dθ_n \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​+d2nyn​​)yn+1​=Kn​n=0∏n​(yn​−d2nxn​​)zn+1​=z0​+n=0∑n​dθn​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​, θn​=arctan(2n1​) 圆周坐标下旋转模式(rotation mode)的公式为 迭代式： {xi+1=xi−diyi2iyi+1=yi+dixi2izi+1=zi−diθiwhere{di=+1,if zi&gt;0di=−1,if zi≤0,θi=arctan(12i)\\begin{cases} x_{i+1} = x_i-d_i\\frac{y_i}{2^i}\\\\ y_{i+1} = y_i+d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i - d_iθ_i\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $z_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $z_i$≤0} \\end{cases},θ_i = arctan(\\frac{1}{2^i})\\\\ ⎩⎪⎨⎪⎧​xi+1​=xi​−di​2iyi​​yi+1​=yi​+di​2ixi​​zi+1​=zi​−di​θi​​where{di​=+1,di​=−1,​if zi​&gt;0if zi​≤0​,θi​=arctan(2i1​) 结果式： xn+1=Kn∏n=0n(xn−dyn2n)yn+1=Kn∏n=0n(yn+dxn2n)zn+1=z0−∑n=0ndθnwhere{d=+1,if zn&gt;0d=−1,if zn≤0, θn=arctan(12n)x_{n+1} = K_n\\prod_{n=0}^{n}(x_n-d\\frac{y_n}{2^n})\\\\ y_{n+1} = K_n\\prod_{n=0}^{n}(y_n+d\\frac{x_n}{2^n})\\\\ z_{n+1} = z_0 - \\sum_{n=0}^{n}dθ_n\\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_n$&gt;0} \\\\ d = -1, &amp; \\text{if $z_n$≤0} \\end{cases},\\ θ_n = arctan(\\frac{1}{2^n})\\\\ xn+1​=Kn​n=0∏n​(xn​−d2nyn​​)yn+1​=Kn​n=0∏n​(yn​+d2nxn​​)zn+1​=z0​−n=0∑n​dθn​where{d=+1,d=−1,​if zn​&gt;0if zn​≤0​, θn​=arctan(2n1​) 三种坐标系 上文只讨论了圆周坐标系，实际cordic算法可用于三种坐标系，进行不同的复杂运算。 圆周坐标系(circular rotations) 线性坐标系(linear rotations) 双曲线坐标系(hyperbolic rotations) 圆周坐标系 之前的所有讨论均基于圆周坐标系。这里不再赘述。 线性坐标系 假设(x1,y1)=(250,100)(x_1,y_1)=(250,100)(x1​,y1​)=(250,100)，要求其在线性坐标系下的旋转角θθθ。首先根据观察可知tanθ=25tanθ=\\frac{2}{5}tanθ=52​ 。这时利用cordic旋转算法进行尝试。 类似的，先逆时针&quot;旋转&quot;45°45°45°进行尝试。根据之前推导的公式可知，此时显然x2=x1=100x_2=x_1=100x2​=x1​=100，y2=y1−x1tan45°=y1−x1y_2=y_1-x_1tan45°=y_1-x_1y2​=y1​−x1​tan45°=y1​−x1​。写成矩阵的形式： [xy]=[10−tan(45°)1][250100]=[10−11][250100]=[250−150]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -tan(45°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 100 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -1&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 100 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] [xy​]=[1−tan(45°)​01​][250100​]=[1−1​01​][250100​]=[250−150​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度超过了范围，则在此基础上顺时针&quot;回转&quot;tan(θ)=12tan(θ)=\\frac{1}{2}tan(θ)=21​的θθθ角（θ=26.565051177078°θ=26.565051177078°θ=26.565051177078°）。写成矩阵的形式： [xy]=[10tan(26.565051177078°)1][250−150]=[10121][250−150]=[250−25]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ tan(26.565051177078°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ \\frac{1}{2}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -150 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] [xy​]=[1tan(26.565051177078°)​01​][250−150​]=[121​​01​][250−150​]=[250−25​] 发现纵坐标y&lt;0y&lt;0y&lt;0，则旋转角度依然不够，则在此基础上顺时针&quot;回转&quot;tan(θ)=14tan(θ)=\\frac{1}{4}tan(θ)=41​的θθθ角（θ=14.036243467926477°θ=14.036243467926477°θ=14.036243467926477°）。写成矩阵的形式： [xy]=[10tan(14.036243467926477°)1][250−25]=[10141][250−25]=[25037.5]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ tan(14.036243467926477°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ \\frac{1}{4}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ -25 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] [xy​]=[1tan(14.036243467926477°)​01​][250−25​]=[141​​01​][250−25​]=[25037.5​] 发现纵坐标y&gt;0y&gt;0y&gt;0，则旋转角度超过了范围，则在此基础上继续逆时针&quot;旋转&quot;tan(θ)=18tan(θ)=\\frac{1}{8}tan(θ)=81​的θθθ角（θ=7.125016348901798°θ=7.125016348901798°θ=7.125016348901798°）。写成矩阵的形式： [xy]=[10−tan(7.125016348901798°)1][25037.5]=[10−181][25037.5]=[2506.25]\\left[ \\begin{matrix} x\\\\ y \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -tan(7.125016348901798°)&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] = \\left[ \\begin{matrix} 1&amp;0\\\\ -\\frac{1}{8}&amp;1 \\end{matrix} \\right] \\left[ \\begin{matrix} 250\\\\ 37.5 \\end{matrix} \\right] = \\left[ \\begin{matrix} 250\\\\ 6.25 \\end{matrix} \\right] [xy​]=[1−tan(7.125016348901798°)​01​][25037.5​]=[1−81​​01​][25037.5​]=[2506.25​] 这时纵坐标已经比较接近000了。类似的，按照这个模式继续算下去，可以不断逼近真实的结果。比如现在的结果范围为(x,y)=(250,6.25±15.625)(x,y)=(250,6.25±15.625)(x,y)=(250,6.25±15.625)，已经接近实际结果(x,y)=(250,0)(x,y)=(250,0)(x,y)=(250,0)了。旋转过程演示图如下。 线性坐标系的&quot;旋转&quot;其实与圆周坐标系下的旋转含义并不相同了，因为这里的矩阵变化（所谓旋转）其实表现的就是一种迭代映射，其变换逻辑图如下： 注意，上述讨论分析的是使结果纵坐标y→0y\\to0y→0的cordic旋转变换，因此是向量模式(vector mode)。 线性坐标的向量模式(vector mode)的公式为（根据上述内容推导，zzz为tan(y1/x1)tan(y1/x1)tan(y1/x1)，注意cordic算法规定迭代n从1开始，且由于没有迭代乘法，并不存在伸缩因子KnK_nKn​） 迭代式： {xi+1=xiyi+1=yi−dixi2izi+1=zi+dixi2iwhere{di=+1,if yi&gt;0di=−1,if yi≤0\\begin{cases} x_{i+1} = x_i\\\\ y_{i+1} = y_i - d_i\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i + d_i\\frac{x_i}{2^i}\\\\ \\end{cases} \\\\ where \\begin{cases} d_i = +1, &amp; \\text{if $y_i$&gt;0} \\\\ d_i = -1, &amp; \\text{if $y_i$≤0} \\end{cases} ⎩⎪⎨⎪⎧​xi+1​=xi​yi+1​=yi​−di​2ixi​​zi+1​=zi​+di​2ixi​​​where{di​=+1,di​=−1,​if yi​&gt;0if yi​≤0​ 结果式： xn+1=xn=x0yn+1=y0−∑n=0ndxn2nzn+1=z0+∑n=1nd2nwhere{d=+1,if yn&gt;0d=−1,if yn≤0x_{n+1} = x_n = x_0\\\\ y_{n+1} = y_0 - \\sum_{n=0}^{n}\\frac{dx_n}{2^n}\\\\ z_{n+1} = z_0 + \\sum_{n=1}^{n}\\frac{d}{2^n} \\\\ where \\begin{cases} d = +1, &amp; \\text{if $y_n$&gt;0} \\\\ d = -1, &amp; \\text{if $y_n$≤0} \\end{cases} xn+1​=xn​=x0​yn+1​=y0​−n=0∑n​2ndxn​​zn+1​=z0​+n=1∑n​2nd​where{d=+1,d=−1,​if yn​&gt;0if yn​≤0​ 圆周坐标下旋转模式(rotation mode)的公式为 迭代式： {xi+1=xiyi+1=yi+dxi2izi+1=zi−dxi2iwhere{d=+1,if zi&gt;0d=−1,if zi≤0\\begin{cases} x_{i+1} = x_i\\\\ y_{i+1} = y_i + d\\frac{x_i}{2^i}\\\\ z_{i+1} = z_i - d\\frac{x_i}{2^i}\\\\ \\end{cases} \\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_i$&gt;0} \\\\ d = -1, &amp; \\text{if $z_i$≤0} \\end{cases} ⎩⎪⎨⎪⎧​xi+1​=xi​yi+1​=yi​+d2ixi​​zi+1​=zi​−d2ixi​​​where{d=+1,d=−1,​if zi​&gt;0if zi​≤0​ 结果式： xn+1=xn=x0yn+1=y0+∑n=0ndxn2nzn+1=z0−∑n=1nd2nwhere{d=+1,if zn&gt;0d=−1,if zn≤0x_{n+1} = x_n = x_0\\\\ y_{n+1} = y_0 + \\sum_{n=0}^{n}\\frac{dx_n}{2^n}\\\\ z_{n+1} = z_0 - \\sum_{n=1}^{n}\\frac{d}{2^n}\\\\ where \\begin{cases} d = +1, &amp; \\text{if $z_n$&gt;0} \\\\ d = -1, &amp; \\text{if $z_n$≤0} \\end{cases} xn+1​=xn​=x0​yn+1​=y0​+n=0∑n​2ndxn​​zn+1​=z0​−n=1∑n​2nd​where{d=+1,d=−1,​if zn​&gt;0if zn​≤0​ 双曲坐标系 双曲坐标系的cordic旋转比较类似于圆周坐标系。 应用问题 cordic功能表 图源为参考文献[6] ，侵删。 cordic计算范围及转换 cordic算法的计算是有范围限制的，超范围的值需要进行转换后才能利用cordic算法进行计算。 cordic计算误差 近似误差和舍入误差 见参考文献[7] FPGA实现 总结 未完待续…长期施工中… 参考资料 [1] 邹熙. 基于CORDIC的指数函数的FPGA实现[J]. 大众科技, 2008, 000(010):36-37. [2] 三角函数计算，Cordic 算法入门 [3] CORDIC_百度百科 [4] 周晓青, 李合生, 陶荣辉, et al. 基于CORDIC算法的双曲正余弦函数FPGA实现[J]. 太赫兹科学与电子信息学报, 2010(2):211-214. [5] cordic算法详解 转载 [6] Xilinx CORDIC算法 [7] Y. H. Hu, “The Quantization Effects of the CORDIC Algorithm”, in IEEE Trans. On Signal Processing, Vol 40, No 4, April 1992","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"math","slug":"ic/math","permalink":"https://blog.honk.wang/categories/ic/math/"}],"tags":[{"name":"cordic","slug":"cordic","permalink":"https://blog.honk.wang/tags/cordic/"}]},{"title":"Clock Domain Crossing","slug":"IC/design/跨时钟域问题","date":"2020-03-16T16:31:34.000Z","updated":"2020-10-31T11:25:55.572Z","comments":true,"path":"posts/Clock-Domain-Crossing-Problem/","link":"","permalink":"https://blog.honk.wang/posts/Clock-Domain-Crossing-Problem/","excerpt":"","text":"全文分析较长，嫌麻烦直接翻到底看结论。 引言 在各种条件下（温度、压力、震动等）电路可能出现偶发性故障，解决难度较大，要减少数字系统中的这种问题，即要保障电路最大程度的可靠性。时序电路中的这种不稳定的状态即称为亚稳态。 时序电路中的触发器需要满足建立时间和保持时间的要求，才能满足电路稳定工作的时序要求。 建立时间：在有效时钟沿到来之前，输入端信号需要保持稳定不变的最小时间。 保持时间：在有效时钟沿到来之后，输入端信号需要保持稳定不变的最小时间。 如何分析建立时间和保持时间呢？这里得从数电基础来分析一下。下面上D触发器的图。图源数字电子技术基础第5版 在CLK上升沿到来之前，CLK=0，G1和G2门的前端会被锁住，Q和Q’保持不变。 因为D端的数据变化经过G6和G5后会控制G3和G4的输出，因此在CLK上升沿到来之前，需要保持G5和G6的输出稳定，这样才能保证G3和G4能够正确输出，实现D值传递到Q的效果。因此在CLK上升沿到来之前，D的变化在G5和G6的传递必须完成。所以其建立时间必须tset≥2tpd（tpd为一个与门的信号延迟时间）。 因为CLK端的数据变化经过G4后会控制G6的输出，因此D的变化不能在G4变化的时候进行，在CLK上升沿到来之后，D必须保持不变直到G4的输出完成。所以其保持时间必须thold≥tpd。其电平转换如下。 以上只是举个例子，实际触发器电路可能不完全等同于此。另外实际情况下各个门电路延迟也并不相同，并且电路本身延迟也不完全一致。总而言之，触发器的建立和保持时间取决于生产工艺，由工艺厂商决定。 由上述分析可知，若时序不能满足建立时间和保持时间要求，输出端值会呈现未知状态，电路进入亚稳态。 跨时钟域主要问题 最好的解决亚稳态的方法就是使用同步设计，同步设计可以通过STA（静态时序分析）来解决时序问题。但实际上绝大部分的ASIC设计是由多个异步的时钟驱动的，因此多时钟的设计里就需要对跨时钟域的信号、数据进行特殊操作来保障电路的稳定性。 跨时钟域（Clock Domain Crossing，CDC）问题主要有以下几种： 亚稳态 确保亚稳态对系统不产生错误影响。 数据丢失 确保信号由快速时钟域向慢速时钟域传播时能被正确捕捉。 数据收敛及多路扇出 确保一组相关联的同步信号在经过不同的路径之后可以在某一个相同的时钟周期正确的到达另一个时钟域。确保在一个信号在跨时钟域出现多路扇出时，后续逻辑得到相同的值。 异步复位 确保异步复位释放时不导致电路出现亚稳态。 下面分别介绍各个问题及其实际解决方法。 单bit-亚稳态 如上图，当信号adat由A时钟域进入B时钟域时，由于信号adat的时钟域和B的时钟域存在频率差和相位差，信号adat可能会在B时钟沿跳变时发生变化（从而不能满足建立时间和保持时间要求），从而出现亚稳态。此时bdat1值可能为1，也可能为0，并且可能到下一次B时钟的上升沿到来时这个不稳定状态仍然没有恢复，这样进入亚稳态的信号bdat1就会传播到下一级电路去。 解决这类问题的办法是使用同步器，也就是常说的打两拍（Double Flip-Flops），即对进入时钟域B的信号经过两级触发器的同步后再使用该信号。 由上图，打了两拍之后，对于进入亚稳态的bdat1来说，在下一个时钟沿到来的时候，他的不稳定值（0或1）会被第二级触发器捕捉到，从而bdat2会有一个稳定的输出（0或1），从而避免了亚稳态的进一步传播。注意，此方法只能避免亚稳态传播，并不保证出现亚稳态时后续电路的结果正确。就像上图中如果bdat1稳定值为0，则bdat2就会继续保持为0，从而两种情况下的输出结果完全不同，可能会影响后端电路。 那是不是打两拍后数据就不存在亚稳态问题了呢？并不是。因为实际情况下bdat1的亚稳态持续时间是有可能持续到第二个时钟沿到来时刻的，即第二个图里的样子。亚稳态的持续时间与触发器的恢复能力有关。 因此在跨两个时钟域的时候是否出现亚稳态情况其实是一个概率问题，可以想得到的是，这个出现概率与两个时钟的频率（频率越高数据越有可能撞上触发器边沿）、触发器的恢复能力等参数有关。概率分析的部分可以见参考资料[5]以及参考资料[6] 跨时钟域同步，为什么两级寄存器结构能够降低亚稳态？的分析，其主要分析参数为MTBF（Mean Time Between Failures，平均故障间隔时间）。其结论是：在一般情况下（典型参数见上述资料），对于绝大多数设计来说，打两拍可以将亚稳态控制在可以接受的范围内。 同步器代码如下。 123456789101112131415161718192021module synchronizer( input clkb , input rst , input adat , output wire bdat2 ); reg[1:0] bdat ; always@(posedge clkb or posedge rst)begin if(rst==1&#x27;b1)begin bdat &lt;= 0; end else begin bdat &lt;= &#123;bdat[0],adat&#125;; end end assign bdat2 = bdat[1]; endmodule 为有效避免跨时钟域带来的亚稳态问题，规范的设计要求 每个独立模块只使用一个时钟； 不同时钟域的模块间如果需要信号交互，必须使用同步器进行同步。； 对系统进行STA（静态时序分析），MIN-MAX Timing Analysis 单bit-数据丢失 如果数据从快的时钟域进入慢的时钟域，则可能会因为快时钟域的信号持续时间过短导致慢时钟域的时钟无法捕获到该信号从而导致数据丢失。 还是上一节的那个电路，按照上图所示时序，在B时钟域的两次上升沿之间，adat持续了一个A时钟域的周期，但是B时钟域无法捕获到该信号，导致数据无法在B时钟域传递下去。解决这种问题最直观的想法就是延长adat信号至少一个bclk的周期，使得bclk能够捕获到他，如下图。 那是不是只要延时就行呢？并不是。注意到因为adat的持续周期大于bclk的周期，这种方法bclk端可能采集到1次adat信号，也可能采集到2次，因此bdat的持续时间是不可控的。所以一般来说还有一种方法，即通过控制信号进行同步反馈。 信号传递如上图所示，adat信号先置高，但暂时不拉低，什么时候拉低呢？等到B时钟域的反馈信号回来之后再拉低。由于跨时钟域，因此在adat1进入B时钟域和反馈信号bdat2进入A时钟域的时候，均打两拍处理亚稳态问题。知道在A时钟域收到反馈信号abdat2后，adat再拉低，bdat2会在之后跟随拉低。这是一种比较保险的办法，但进行同步需要很长的延迟时间。 代码如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344module synchronizer_aclk( input aclk , input rst , input bdat2 , input a , output reg adat , output reg adat1 ); reg abdat1 ; reg abdat2 ; always@(posedge aclk or posedge rst)begin if(rst==1&#x27;b1)begin adat &lt;= 0; adat1 &lt;= 0; end else begin adat1 &lt;= adat; if(a==1&#x27;b1)begin adat &lt;= 1; end else if(abdat2==1&#x27;b1)begin adat &lt;= 1&#x27;b0; end else begin adat &lt;= adat; end end end always@(posedge aclk or posedge rst)begin if(rst==1&#x27;b1)begin abdat1 &lt;= 0; abdat2 &lt;= 0; end else begin abdat1 &lt;= bdat2; abdat2 &lt;= abdat1; end endendmodule 12345678910111213141516171819202122module synchronizer_bclk( input bclk , input rst , input adat1 , output reg bdat2 ); reg bdat1 ; always@(posedge bclk or posedge rst)begin if(rst==1&#x27;b1)begin bdat1 &lt;= 0; bdat2 &lt;= 0; end else begin bdat1 &lt;= adat1; bdat2 &lt;= bdat1; end endendmodule 多bit-数据收敛和多路扇出 数据收敛问题情况较多，主要原因都是因为跨时钟域的一组相关联的信号在跨时钟域时因为传播的延时路径不同的误差导致进入另一个时钟域时出现的误码问题。下面分多种情况讨论一下并介绍解决方法。 数据收敛-2bit同时变化的信号 如下图，A时钟域的触发器A需要a_load和a_en两个信号同时为1才能触发adata加载到abus，而这两个信号b_load和b_en均来自另一个时钟域B。 当b_load和b_en跨时钟域传递时存在小的误差延时，而这个误差延迟正好被aclk捕捉到，这样会最终导致a_en比a_load信号晚一拍出来。从而在A时钟域，这两个信号不会同时出现，因此adata也就不会被加载到abus端。 解决这个问题的办法就是很自然就是跨时钟域只传递一个使能即可，传递过来同步之后再进行信号分配，如下图所示。 数据收敛-2bit有相位差的信号 如下图，A时钟域的触发器A需要两拍aen1和aen2分别加载数据a1到a2，然后a2到a3，而这两个信号ben1和ben2均来自另一个时钟域B。 当ben1和ben2跨时钟域传递时存在小的误差延时，而在A时钟域，这个误差延迟正好被aclk捕捉到，这两个信号aen1和aen2就会相差一整个时钟周期，最终导致a2端能加载而到a3却不能。 解决这个问题的办法，同样很自然就是跨时钟域只传递一个使能，传递过来同步之后再对信号打拍，如下图所示。 多路扇出-2bit编码信号 如下图，A时钟域的2-4译码器需要对adec[1]和adec[0]编码信号进行解码，而这两个信号的来源bdec[1]和bdec[0]均来自另一个时钟域B。 当ben[1]和ben[2]跨时钟域传递时存在小的误差延时，而在A时钟域，这个误差延迟正好被aclk捕捉到，这两个信号aen[1]和aen[2]就会相差一整个时钟周期，最终导致译码结果会有一个周期异常。 解决这个问题的办法，就不能跨时钟域只用一个使能信号了。因为两位信号为编码（数据）信号而不再是简单的控制信号，逻辑功能已经不同。而其解决办法其实有两种： 给A和B跨时钟域添加一个单独的控制使能信号来控制编码信号传输 即保证在A时钟域，控制信号只在a_dec[1]和a_dec[0]稳定的情况下有效，这样就需要几个条件： 控制信号在b时钟域要在编码信号b_dec[1]和b_dec[0]变化开始后一个clkb后再变化 控制信号在b时钟域要在编码信号b_dec[1]和b_dec[0]变化结束前一个clkb先结束 控制信号的持续时间必须大于一整个clka周期 这样其实就需要对两个时钟频率即相位控制进行比较清晰的分析才能实现。 在B时钟域先进行2-4编码（即转换为独热码），然后在A时钟域通过状态机过滤掉异常的编码值（即不是独热码的值） 当然跟前一种方法一样，独热码的信号持续时间必须大于一整个clka周期，以便被clka捕捉到。 多bit信号-综合问题 其实之前讨论的三种情况都可以总结为相同的思路。 找到问题点，即数据发生变化且被另一个时钟域捕获的瞬间 将多bit跨时钟域信号想办法转换为单bit跨时钟域信号，然后通过门控、编解码等方法解决问题。 但是这种解决办法可能对信号的持续时间，还有触发时间等有不同的要求，并且不同的问题需要进行不同的具体分析。那有没有通用的方法可以传递多位的信号呢？还真有。下面介绍两种常用方法。 握手协议 总体思路其实与之前的思路一致，将多bit数据通过单bit控制信号来传递。 在需要传递一个data的时候，发送端时钟域A先将data放到总线上，然后输出一个data_valid信号； data_valid信号跨时钟域并经过处理后传递到接收端时钟域B； 接收端时钟域B采集到这个data_valid信号之后，从总线上拿走data，再反馈acknowledge信号给原时钟域A； 反馈的acknowledge信号跨时钟域并经过处理后传递到发送端时钟域A； 发送端时钟域A再继续发送下一个数据。 总体结构为一次发送，一次返回，结构图如下。 这个结构也可以有其他变种： 一次发送，两次返回 为了更保险，在每次直到接收端发现data_valid拉低之后，再发送一个ready信号，而发送端时钟域A接受到ready之后再继续发送下一个数据。即acknowledge用于拉低data_valid信号，然后再用控制信号ready来表示收到data_valid拉低，并开始下一次数据发送。结构图如下。 两次发送，两次返回 最保险的办法，就是发送端时钟域A发送data_valid信号，接收端返回acknowledge信号，发送端发送cancel_acknowledge信号，接收端返回cancel_finish信号。通过两次握手形成完整的同步机制。结构图如下。 这几种结构进行数据交互的延迟时间依次增大，但是遇到跨时钟域问题的概率却依次降低，实际设计时应在评估后结合具体实例选取不同的方法。 异步fifo 使用异步双口RAM，或异步FIFO，是一种非常方便的处理跨时钟域多bit数据传递的方法。发送端只需要根据自己时钟域A不断的把数据放进FIFO，接收端再根据自己时钟域B不断取数据即可，当然设计这种FIFO其实有一定难度。异步FIFO设计的主要难点就在于FIFO空信号（EMPTY）和FIFO满信号(FULL)的操作。为什么呢？因为空满信号是通过发送端的写地址和接收端的读地址进行对比来产生的。 举个例子，假设我们设计一个深度为16的FIFO，其地址从0~15，那么FIFO满的时候就是写地址增加到15的时候，FIFO空的时候就是读地址减少到0的时候。但是地址的传递是多bit跨时钟域的，存在跨时钟域的问题，即可能多bit数据传递因为传播的延时路径不同的误差存在误码可能。如果我们地址使用一般的二进制计数，假设我写地址在7的之后写入一个数据，写地址加1，即地址会从7（0111）跳到8(1000)（在发送端时钟域A），但是由于各bit信号的传递存在很小的误差延时，导致其跳转的中间状态可能被接收端时钟域B捕获到，形成异常的地址（这种情况类似于两bit关联-两个编码信号的情况），而地址异常跳0的瞬间被接收端时钟域B捕获到就会产生错误的FIFO空信号（EMPTY）。同理，由于地址跨时钟域传递的问题可能导致发送端时钟域接收到地址异常跳15的瞬间，从而产生错误的FIFO满信号（FULL）。 那么如何处理这种地址跨时钟域传递的问题呢？其实思路还是跟最开始一致，即我们将多bit跨时钟域信号想办法转换为单bit跨时钟域信号，然后通过一些普通方法来解决问题。在两bit关联-两个编码信号那一节中使用独热码编码来进行多bit转单bit信号，而对于地址信号这种每次只加一或减一的连续信号，可以使用格雷码来进行编码。由于格雷码相邻两个码值只有1个bit不同，因此即使出现异常，最多也就保持上一个正确的值而已。 根据不同的设计，可能会用到格雷码的编解码器。代码如下。 1234567891011121314module gray2bin #(parameter WIDTH = 4)( input [WIDTH-1:0] gray , output reg[WIDTH-1:0] bin ); integer i; always@(gray)begin for (i=0;i&lt;WIDTH;i=i+1) bin[i] = ^(gray&gt;&gt;i); endendmodul 123456789module bin2gray #(parameter WIDTH = 4)( input [WIDTH-1:0] bin , output wire[WIDTH-1:0] gray ); assign gray = (bin&gt;&gt;1)^(bin);endmodule 格雷码计数器的代码就不贴了，就是在普通二进制计数器后加上格雷码编码。 因此。异步FIFO的设计架构如下。主要是几个部分： 发送端的FIFO控制器，负责将数据放入FIFO，并在接收FIFO满标志时不再放数据 接收端的FIFO控制器，负责从FIFO取出数据，并在接收FIFO空标志时不再取数据 FIFO满标志控制器以及FIFO空标志控制器，负责进行地址的格雷码转换并输出标志 同步器，负责同步收发两端发送给对方的地址信号 给自己留个作业，以后有时间了自己写一个异步FIFO。 1module fifo_async 单bit-异步复位 数字系统的上电复位信号都是异步的，复位信号的亚稳态都是在复位信号释放的时候出现的。对于异步复位信号，引入了标准的恢复时间(Recovery Time)和移除时间(Removal Time)的概念。本质上还是建立时间和保持时间的概念。而解决异步复位问题，一般就是一句口诀：异步复位，同步释放。即在进行异步复位释放的时候，先对复位信号打两拍，同步处理之后的信号再作为系统的复位信号使用。 结语 单bit亚稳态问题一般解决方法：打两拍。如果系统频率很高或者有其他特殊约束，也可能打3拍，要分析MTBF； 数据丢失的问题一般解决方法：延宽信号或进行握手； 多bit数据传输的一般解决方法：握手协议（2次，3次或4次），或使用异步FIFO（格雷码转换地址信号）； 异步复位问题的解决方法：异步复位，同步释放。 同时，在过程中作者验证了另外几个小问题，限于篇幅不做分享，列在下方与读者一共同思考。 常说的竞争和冒险与亚稳态问题有什么关系？ 格雷码编码是如何保证相邻码之间只有一个bit有变化的？ 本文部分的内容完全来自参考资料[1]，大家有兴趣可以去看看英文原版，写的非常好。 参考资料 [1] Synthesis and Scripting Techniques for Designing Multi-Asynchronous Clock Designs [2] 揭秘《跨时钟域处理》三大方法 [3] 万年不翻的数字电子技术基础（第5版） [4] 芯片设计中跨时钟域(CDC)5大问题与解决方法 [5] William J. Dally and John W. Poulton, Digital Systems Engineering, Cambridge University Press, 1998, pp. 469-470. [6] 跨时钟域同步，为什么两级寄存器结构能够降低亚稳态？","categories":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"design","slug":"ic/design","permalink":"https://blog.honk.wang/categories/ic/design/"}],"tags":[{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/tags/ic/"},{"name":"cdc","slug":"cdc","permalink":"https://blog.honk.wang/tags/cdc/"}]},{"title":"Gvim-Verilog-Handbook","slug":"IC/editor/Gvim-Verilog-HB","date":"2020-03-06T15:54:16.000Z","updated":"2020-10-31T11:25:55.483Z","comments":true,"path":"posts/Gvim-Verilog-HB/","link":"","permalink":"https://blog.honk.wang/posts/Gvim-Verilog-HB/","excerpt":"","text":"此篇为中篇，主要介绍部分功能使用。部分功能可能已改动，只做参考。 点击查看终篇效果 代码编写 添加头部 在Normal模式下输入header（或菜单栏中Verilog的AddHeader），自动生成文件头部。 可在automatic.vim的AddHeader()函数中修改相关的参数模板。 1function AddHeader() 添加波形图 点击GUI界面工具栏中的AddClk，AddSig和AddBus（或菜单栏中的TimingWave）分别添加时钟，一般信号，总线信号，末尾取反标志位以及分割线。 通过快捷键Ctrl+F8或者TimingWave中的Invert键进行信号的翻转和总线的调整，信号末尾的取反标志位代表信号翻转时使用下降沿触发（默认为上升沿触发）。 波形的相关配置在automatic.vim中的位置及其含义如下。 123456let s:sig_offset = 13 &quot;信号偏移值let s:clk_period = 8 &quot;一个时钟间隔8个空格周期let s:clk_num = 16 &quot;产生16个时钟let s:cq_trans = 1 &quot;第一个触发点间隔1个空格周期let s:wave_max_wd = s:sig_offset + s:clk_num*s:clk_period&quot;0 is clk posedge, 4 is clk negedge 添加代码段 添加always块 多种always块添加，可通过菜单栏AlwaysBlock的选项点击或工具栏部分图标点击，或者通过快捷键al，修改配置与添加文件头部的功能类似，在automatic.vim相关函数中对应修改即可。 添加状态机 快捷键fsm，生成三段式状态机模板，修改配置与添加文件头部的功能类似，在automatic.vim相关函数中对应修改即可。 类似添加 还有添加单行注释、选定后添加多行注释、添加reg/wire注释块、添加主程序注释块等。参考automaic.vim配置即可。插入模式下快捷键F2添加时间，参考vimrc配置。 信号操作 产生信号定义 端口信号定义 输入信号后，在对应信号行Normal模式下输入;di产生input信号声明，输入;dow产生output wire 信号声明，输入;dor产生output reg信号声明，注意此声明不能带位宽，不然会被截位。 reg/wire信号定义 输入信号后，在对应信号行Normal模式下;dr产生input信号声明，;dw产生output wire 信号声明，注意此声明不能带位宽，不然会被截位。 input/output定义切换 快捷键Shift+F9（或菜单栏的Verilog）调整端口信号input/output切换 信号对齐 输入信号位宽之后信号对齐会有问题，通过快捷键F7对齐输入输出端口的格式；通过快捷键F8对齐reg/wire的格式；通过快捷键F6调整例化模块的端口对齐。 自动例化 将需要例化的模块与顶层模块放在一个文件夹下，然后在顶层模块中输入 1uart u_uart(/*autoinst*/); //模块名+u_模块名+(/*autoinst*/); 注意要添加分号 然后使用快捷键Shift+F3（或菜单栏Verilog功能）即可。例化端口自带input和outrput注释，可以更改automati.vim代码选择不添加。 另外，自动例化autoinst功能里带有例化更新，例化顺序重排，重对齐等操作，具体可尝试使用。AutoArg功能用于声明输入输出，现在暂时不太需要使用了。 自动定义reg/wire 慎用，部分功能有异常。在需要添加reg/wire定义的位置输入 1/*autodef*/ 然后使用快捷键Shift+F2（或菜单栏Verilog功能）即可，此功能会自动定义当前未定义的例化模块端口，模块内使用到的wire和reg信号。 自动连线 待补充。 递增/减命名 进入Gvim列操作后选定单列后（在windows下Ctrl+q，Linux下Ctrl+v），输入 1:I 则生成第一个数为起始数的递增序列。若输入 1:I -1 则生成第一个数为起始数的递减序列。 IDE操作 树形拓扑 文件树 Normal模式下输入 1:NERdTree 显示当前文件夹的文件树。 RTL树 RTL树需要perl脚本支持，linux下操作比较方便。Windows下可用git的git-bash集成的perl。 在.v文件夹下使用调用git-bash，并把名为ctags_gen的perl脚本放入该文件夹，在git-bash中输入命令 1perl ctags_gen *.v 这里会生成一个模块之间关联信息的文件tags。这样在文件夹下用Gvim打开.v的顶层文件，命令行模式输入命令 1:RtlTree 即可打开Rtl树列表。 代码检查 代码检查需要iverilog作为Linter来进行操作。下载windows版的iverilog并将iverilog.exe的地址添加到环境变量$PATH中。Syntasticcheck会调用cmd.exe（或git-bash，可通过vimrc配置）作为shell启动iveirllog检查代码，并将结果返回Syntasticcheck，然后由Syntasticcheck显示到Gvim编辑器中。在Normal模式下输入 1:SyntasticCheck 即可进行代码检查。 BTW 据说Emacs的verilog-mode插件集成度高且很好用，但在vim中调用貌似不太方便，详见用Emacs写Verilog 。不过现在这版Gvim作者个人用着已经很方便了，且自己配置也很方便，所以暂不考虑替换。","categories":[{"name":"editor","slug":"editor","permalink":"https://blog.honk.wang/categories/editor/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"}]},{"title":"Gvim-Verilog-Env","slug":"IC/editor/Gvim-Verilog-Env","date":"2020-02-23T11:19:27.000Z","updated":"2020-11-02T16:03:42.844Z","comments":true,"path":"posts/Gvim-Verilog-env/","link":"","permalink":"https://blog.honk.wang/posts/Gvim-Verilog-env/","excerpt":"","text":"此篇为初篇，主要介绍环境搭建。部分功能可能已改动，只做参考。 点击查看终篇效果 综述 主要参考了下面几个链接的vimrc配置及脚本： Kevin：如何提高敲代码的速度？ 基于GVim搭建Verilog开发环境 全世界最好的编辑器VIM之Windows配置（gvim） vim auto script for verilog &amp; RtlTree - (like Emacs, Verdi) automatic for Verilog &amp; RtlTree : Automatic generator for Verilog HDL (upgraded) &amp; RtlTree Verilog专用设置 vimrc配置 根据Kevin：如何提高敲代码的速度？，修改相关vimrc的配置，根据自己的操作习惯做了一些快捷键映射的修改，同时添加部分注释。 自动化脚本 在使用上述vimrc配置，搜索相关资料时，作者在vim auto script for verilog &amp; RtlTree - (like Emacs, Verdi)意外发现一个Verilog自动化脚本。此脚本包含很多Vim相关自动化功能，只需要自己修改部分脚本文件即可使用。 安装方法 在源地址下载链接后，将.vim/plugin文件夹下automatic.vim放入自己的Gvim同样位置的plugin文件夹下。另外可粘贴/after文件夹至vim源文件位置，作为Gvim工具栏使用的icon图标。由于原作者使用的是Linux，因此在Windows下需要重新配置图片位置及格式。 我的VIM安装位置为E:\\Vim\\vim73，因此将automatic.vim的下列代码 12345678910111213amenu ToolBar.-Show- :amenu icon=$HOME/.vim/after/ShowCall.xpm ToolBar.ShowCall :call ShowCall()&lt;CR&gt;amenu icon=$HOME/.vim/after/ShowDef.xpm ToolBar.ShowDef :call ShowDef()&lt;CR&gt;amenu ToolBar.-TimingWave- :amenu icon=$HOME/.vim/after/AddClk.xpm ToolBar.AddClk :call AddClk()&lt;CR&gt;amenu icon=$HOME/.vim/after/AddSig.xpm ToolBar.AddSig :call AddSig()&lt;CR&gt;amenu icon=$HOME/.vim/after/AddBus.xpm ToolBar.AddBus :call AddBus()&lt;CR&gt;amenu icon=$HOME/.vim/after/AddNeg.xpm ToolBar.AddNeg :call AddNeg()&lt;CR&gt;amenu icon=$HOME/.vim/after/AddBlk.xpm ToolBar.AddBlk :call AddBlk()&lt;CR&gt;amenu ToolBar.-Always- :amenu icon=$HOME/.vim/after/alpn.xpm ToolBar.alpn :call AlBpn()&lt;CR&gt;amenu icon=$HOME/.vim/after/al.xpm ToolBar.al :call AlB()&lt;CR&gt;amenu icon=$HOME/.vim/after/alnn.xpm ToolBar.alnn :call AlBnn()&lt;CR&gt; 修改为(这里$VIM为指向E:\\VIM的环境变量) 12345678910111213amenu ToolBar.-Show- :amenu icon=$VIM/vim73/after/ShowCall.bmp ToolBar.ShowCall :call ShowCall()&lt;CR&gt;amenu icon=$VIM/vim73/after/ShowDef.bmp ToolBar.ShowDef :call ShowDef()&lt;CR&gt;amenu ToolBar.-TimingWave- :amenu icon=$VIM/vim73/after/AddClk.bmp ToolBar.AddClk :call AddClk()&lt;CR&gt;amenu icon=$VIM/vim73/after/AddSig.bmp ToolBar.AddSig :call AddSig()&lt;CR&gt;amenu icon=$VIM/vim73/after/AddBus.bmp ToolBar.AddBus :call AddBus()&lt;CR&gt;amenu icon=$VIM/vim73/after/AddNeg.bmp ToolBar.AddNeg :call AddNeg()&lt;CR&gt;amenu icon=$VIM/vim73/after/AddBlk.bmp ToolBar.AddBlk :call AddBlk()&lt;CR&gt;amenu ToolBar.-Always- :amenu icon=$VIM/vim73/after/alpn.bmp ToolBar.alpn :call AlBpn()&lt;CR&gt;amenu icon=$VIM/vim73/after/al.bmp ToolBar.al :call AlB()&lt;CR&gt;amenu icon=$VIM/vim73/after/alnn.bmp ToolBar.alnn :call AlBnn()&lt;CR&gt; 这样打开Gvim就可以看见菜单栏和工具栏了。 下面介绍这个脚本的一些自动化功能。 添加时序波形TimingWave 在编辑器内可以添加时序波形，通过菜单栏、工具栏以及快捷键操作。可以添加时钟（clk），信号（sig）和总线（bus）信号。通过翻转（Invert，快捷键ctrl+F8）操作信号。 配置参数在automatic.vim的如下位置： 123456let s:sig_offset = 13let s:clk_period = 8let s:clk_num = 16let s:cq_trans = 1let s:wave_max_wd = s:sig_offset + s:clk_num*s:clk_period&quot;0 is clk posedge, 4 is clk negedge sig_offset：产生信号的偏移宽度 clk_period: 产生的时钟信号的周期 clk_num: 产生的时钟信号的个数 cq_trans: 第几个沿开始跳变。0代表上升沿，4代表下降沿。这里用1表示上升沿跳变，延迟1个单位。 输出的波形样式如下： 添加always块和头部 在在编辑器内可以添加always块和文件头，通过菜单栏、工具栏或快捷键操作。前面的vimrc配置中其实已经有简洁版的always块生成方法（输入&quot;al&quot;），这里使用脚本可以使得修改配置更加简单，因为配置是通过函数输入的，不需要再手动去找位置改代码。 想要修改always的生成逻辑，修改automatic.vim的如下代码即可（一共四种类型的alwyas块，这里只放一种作参考）： 12345678910111213141516&quot;Always Block definition &#123;&#123;&#123;1function AlBpn() &quot;&#123;&#123;&#123;2 let lnum = line(&quot;.&quot;) for idx in range(1,7) call append(lnum,&quot;&quot;) endfor call setline(lnum+1,&quot;always @(posedge clk or negedge rst_n) begin&quot;) call setline(lnum+2,&quot; if(!rst_n) begin&quot;) call setline(lnum+3,&quot; &quot;) call setline(lnum+4,&quot; end else if() begin&quot;) call setline(lnum+5,&quot; end else begin&quot;) call setline(lnum+6,&quot; end&quot;) call setline(lnum+7,&quot;end&quot;) call cursor(lnum+3,9)endfunction &quot;&#125;&#125;&#125;2 同样的方法可以修改添加头部设置。这里推荐删除原vimrc配置产生头文件的部分代码。 因为原vimrc配置由于头部过长，修改配置非常麻烦，但在此脚本的函数下比较方便。修改的代码位置如下： 1234567891011121314151617181920212223242526272829function AddHeader() &quot;&#123;&#123;&#123;2 let line = getline(1) if line =~ &#x27;// +FHDR&#x27; return endif let company = system(&quot;echo $COMPANY&quot;) let company = substitute(company,&#x27;\\n&#x27;,&#x27;&#x27;,&#x27;&#x27;) if company =~ &#x27;COMPANY:&#x27; echohl WarningMsg | echo &quot;unix env $COMPANY: Undefined variable. Please set_env COMPANY in ~/.cshrc&quot; | echohl None endif &quot;=============================================================== &quot; Add File Header &quot;=============================================================== let filename = expand(&quot;%&quot;) call append(0, &quot;// +FHDR------------------------------------------------------------&quot;) call append(1, &quot;// Copyright (c) &quot;.strftime(&quot;%Y &quot;) . company . &quot;.&quot;) call append(2, &quot;// ALL RIGHTS RESERVED&quot;) call append(3, &quot;// -----------------------------------------------------------------&quot;) call append(4, &quot;// Filename : &quot;.filename) call append(5, &quot;// Author : &quot;.s:GetUserName()) call append(6, &quot;// Created On : &quot;.strftime(&quot;%Y-%m-%d %H:%M&quot;)) call append(7, &quot;// Last Modified : &quot;) call append(8, &quot;// -----------------------------------------------------------------&quot;) call append(9, &quot;// Description:&quot;) call append(10, &quot;//&quot;) call append(11, &quot;//&quot;) call append(12, &quot;// -FHDR------------------------------------------------------------&quot;) call append(13, &quot;&quot;)endfunction &quot;&#125;&#125;&#125;2 注意这里作者使用的姓名、公司等是在linux系统下自动配置的，可以根据自己的需求自行修改（本人依旧采用vimrc配置头部的格式，只是改成了使用脚本的方法）。修改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344function AddHeader() &quot;&#123;&#123;&#123;2 let line = getline(1) if line =~ &#x27;// +FHDR&#x27; return endif let company = system(&quot;echo $COMPANY&quot;) let company = substitute(company,&#x27;\\n&#x27;,&#x27;&#x27;,&#x27;&#x27;) if company =~ &#x27;COMPANY:&#x27; echohl WarningMsg | echo &quot;unix env $COMPANY: Undefined variable. Please set_env COMPANY in ~/.cshrc&quot; | echohl None endif &quot;=============================================================== &quot; Add File Header &quot;=============================================================== let filename = expand(&quot;%&quot;) call append(0, &quot;// =================================================================================&quot;) call append(1, &quot;// Project Name : Test&quot;) call append(2, &quot;// Device : Xlinx&quot;) call append(3, &quot;// Author : HonkW&quot;) call append(4, &quot;// Email : honkwang93@gmail.com&quot;) call append(5, &quot;// Website : https://honk.wang&quot;) call append(6, &quot;// Create Time : &quot;.strftime(&quot;%Y/%m/%d %H:%M&quot;)) call append(7, &quot;// File Name : .v&quot;) call append(8, &quot;// Module Name :&quot;) call append(9, &quot;// &quot;) call append(10, &quot;// CopyRight(c) 2020, NPIC&quot;) call append(11, &quot;// All Rights Reserved&quot;) call append(12, &quot;// &quot;) call append(13, &quot;// =================================================================================&quot;) call append(14, &quot;// Modification History:&quot;) call append(15, &quot;// Date By Version Change Description&quot;) call append(16, &quot;// ---------------------------------------------------------------------------------&quot;) call append(17, &quot;// &quot;.strftime(&quot;%x&quot;).&quot; Honk 1.0 Original&quot;) call append(18, &quot;// &quot;) call append(19, &quot;// =================================================================================&quot;) call append(20, &quot;`timescale 1ns/1ns&quot;) call append(21, &quot;module&quot;) call append(22, &quot;( &quot;) call append(23, &quot; &quot;) call append(24, &quot; &quot;) call append(25, &quot;);&quot;) call append(26, &quot; &quot;) call append(27, &quot;endmodule&quot;) call cursor(8,19)endfunction &quot;&#125;&#125;&#125;2 当然，为了和我的vimrc统一，添加了map的快捷键设置，快捷键依旧保持为&quot;hd&quot;，然后删除了vimrc中冗长且不好修改的头部文件配置代码。 1map hd :call AddHeader()&lt;CR&gt;i 实例/模块搜索 可以通过Search菜单栏上下搜索.v文件中多个例化模块，或者搜索module。 单行/多行注释 单行注释可直接通过快捷键或菜单栏点击生成，格式可在automatic.vim代码中自行修改。 多行注释注意先选中需要注释的内容再使用快捷键或菜单栏点击，否则可能出现异常。 自动例化 自动进行模块的端口例化。下面以一个例子作为说明： 假设已完成模块的文件名为sdrmc_state.v，模块名为sdrmc_state，模块端口如下。 1234567891011121314151617module sdrmc_state ( // Outputs pre_sd_ras_p, pre_sd_cas_p, pre_sd_we_p, pre_ld_brst, pre_ld_rcd, pre_ld_cslt, pre_clr_ref, pre_sd_doe_n, pre_sd_doe2_n, pre_sd_ready, pre_sd_add_mx, pre_ad_tri, // Inputs Reset, Clk, brst_end, cslt_end, rcd_end, auto_ref, ki_end, clr_ref, Act_st, write_st ); output pre_sd_ras_p, pre_sd_cas_p, pre_sd_we_p, pre_ld_brst; output pre_ld_rcd, pre_ld_cslt, pre_clr_ref, pre_ad_tri; output pre_sd_doe_n, pre_sd_doe2_n, pre_sd_ready, pre_sd_add_mx; input Reset, Clk, brst_end, cslt_end, rcd_end; input auto_ref, ki_end, clr_ref; input [2:0] Act_st; input write_st; 在同一文件夹下新建一个.v文件。假设在这个文件例化sdrmc_state模块，则只需要在代码中输入(注意autoinst的输入方法，以及最后必须加分号)： 1sdrmc_state u_sdrmc_state(/*autoinst*/); 鼠标点中模块实例化行（autoinst关键字所在行），然后选择菜单Verilog -&gt; AutoInst， 即完成自动例化功能 （或使用快捷键）。 自动例化状态如下： 12345678910 sdrmc_state u_sdrmc_state(/*autoinst*/ .pre_sd_ras_p (pre_sd_ras_p ), // output .pre_ld_rcd (pre_ld_rcd ), // output .pre_sd_doe_n (pre_sd_doe_n ), // output .Reset (Reset ), // input .auto_ref (auto_ref ), // input .Act_st (Act_st[2:0] ), // input .write_st (write_st ) // input ); 同时，原作者开发了几个实用的自动例化的相关功能 自动例化更新： 功能用于提示当子模块有接口改变后，快速的知道有哪些模块被添加或者被删除 提示会用注释的方式在模块port例化行的末尾加上，修改连线代码后，请自行删除。 // INST_NEW 表示当前行，为子模块新增加的信号 // INST_DEL 表示当前行，子模块已经将此信号删除 鼠标点中模块实例化行（autoinst关键字所在行），然后选择菜单 Verilog -&gt; AutoInstUpdate, AutoInstUpdateOrder 是将连线顺序重新排布为子模块接口定义的顺序，方便对应 添加例化模块的端口方向： 鼠标点中模块实例化行（autoinst关键字所在行），然后选择菜单 Verilog -&gt; AppendPortDirectionToInst 注意这个功能是没有添加端口方向的例化模块使用的。如果使用的原作者的自动例化功能，是自动附带端口方向的。如果想取消这个功能，可以到automatic.vim的function AutoInst中修改部分代码 12345if value[7] == 1 let tmp_line = tmp_line . suffix_margin . &#x27;) // &#x27; . io_direlse let tmp_line = tmp_line . suffix_margin . &#x27;), // &#x27; . io_direndif 修改为： 12345if value[7] == 1 let tmp_line = tmp_line . suffix_margin . &#x27;) &#x27;else let tmp_line = tmp_line . suffix_margin . &#x27;), &#x27;endif 自动定义wire / reg （以下为原作者语）：此功能强烈依赖用户良好的verilog编码习惯，自己尝试后请慎重选择试用。 菜单Verilog -&gt; AutoDef, 脚本会在autodef（请用注释符包起来）位置开始自动定义数据类型，当然不能识别所有的结构，未完全定义部分（会有提示，但测试中有遇到没有完全提示的情况）请自行添加到autodef结构之外， 避免重新autodef时被脚本删除。 此功能与vimrc中的配置有所重复（可查看vimrc配置文件），故暂不使用。 语法高亮 根据vim语法高亮—verilog/systemverilog的说法： This script extends Verilog syntax highlighting, which comes along with Vim 6.3, and adds SystemVerilog stuff to it. It will recognize Verilog and SystemVerilog syntax in *.v, *.vh and *.sv files. The new syntax is named as “verilog_systemverilog”. If your scripts are loaded correctly, you should see this syntax name when you execute the Vim command “:set syntax?” in your Verilog/SystemVerilog files. 因此只有需要使用systemverilog的时候才需要，不然vim是自带verilog语法高亮的。安装步骤在链接中也有说，将三个文件分别拷贝到对应位置即可。此自动化脚本的压缩包内也包含语法高亮相关的配置文件。因暂时不使用systemverilog，故不使用此语法高亮扩展。 成对标签跳转 此脚本将matchit.vim文件放到plugin文件夹中，并在vimrc添加对标如下: 123456789101112let b:match_words = &#x27;\\&lt;function\\&gt;:\\&lt;endfunction\\&gt;,&#x27; \\ . &#x27;\\&lt;task\\&gt;:\\&lt;endtask\\&gt;,&#x27; \\ . &#x27;\\&lt;module\\&gt;:\\&lt;endmodule\\&gt;,&#x27; \\ . &#x27;\\&lt;begin\\&gt;:\\&lt;end\\&gt;,&#x27; \\ . &#x27;\\&lt;case\\&gt;:\\&lt;endcase\\&gt;,&#x27; \\ . &#x27;\\&lt;class\\&gt;:\\&lt;endclass\\&gt;,&#x27; \\ . &#x27;\\&lt;for\\&gt;:\\&lt;endfor\\&gt;,&#x27; \\ . &#x27;\\&lt;while\\&gt;:\\&lt;endwhile\\&gt;,&#x27; \\ . &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; \\ . &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; \\ . &#x27;\\&lt;\\(ifdef\\|ifndef\\)\\&gt;:\\&lt;\\(else\\|elsif\\)\\&gt;:\\&lt;endif\\&gt;,&#x27; \\ . &#x27;`\\&lt;\\(ifdef\\|ifndef\\)\\&gt;:`\\&lt;\\(else\\|elsif\\)\\&gt;:`\\&lt;endif\\&gt;&#x27; 参考基于GVim搭建Verilog开发环境，因Gvim的macro文件夹自带matchit.vim，只是平时未使用。因此直接在vimrc中添加路径即可。另外添加部分成对标签。最终在vimrc中添加如下代码： 123456789101112131415161718192021222324252627282930&quot; =============================================================&quot; 成对标签设置&quot; =============================================================source $VIMRUNTIME/macros/matchit.vimlet b:match_ignorecase=0let b:match_words= \\ &#x27;\\&lt;begin\\&gt;:\\&lt;end\\&gt;,&#x27; . \\ &#x27;\\&lt;if\\&gt;:\\&lt;else\\&gt;,&#x27; . \\ &#x27;\\&lt;module\\&gt;:\\&lt;endmodule\\&gt;,&#x27; . \\ &#x27;\\&lt;class\\&gt;:\\&lt;endclass\\&gt;,&#x27; . \\ &#x27;\\&lt;program\\&gt;:\\&lt;endprogram\\&gt;,&#x27; . \\ &#x27;\\&lt;clocking\\&gt;:\\&lt;endclocking\\&gt;,&#x27; . \\ &#x27;\\&lt;property\\&gt;:\\&lt;endproperty\\&gt;,&#x27; . \\ &#x27;\\&lt;sequence\\&gt;:\\&lt;endsequence\\&gt;,&#x27; . \\ &#x27;\\&lt;package\\&gt;:\\&lt;endpackage\\&gt;,&#x27; . \\ &#x27;\\&lt;covergroup\\&gt;:\\&lt;endgroup\\&gt;,&#x27; . \\ &#x27;\\&lt;primitive\\&gt;:\\&lt;endprimitive\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;interface\\&gt;:\\&lt;endinterface\\&gt;,&#x27; . \\ &#x27;\\&lt;function\\&gt;:\\&lt;endfunction\\&gt;,&#x27; . \\ &#x27;\\&lt;task\\&gt;:\\&lt;endtask\\&gt;,&#x27; . \\ &#x27;\\&lt;for\\&gt;:\\&lt;endfor\\&gt;,&#x27; . \\ &#x27;\\&lt;while\\&gt;:\\&lt;endwhile\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;case\\&gt;\\|\\&lt;casex\\&gt;\\|\\&lt;casez\\&gt;:\\&lt;endcase\\&gt;,&#x27; . \\ &#x27;\\&lt;fork\\&gt;:\\&lt;join\\&gt;\\|\\&lt;join_any\\&gt;\\|\\&lt;join_none\\&gt;,&#x27; . \\ &#x27;`ifdef\\&gt;:`else\\&gt;:`endif\\&gt;,&#x27; 配置完成后，在Gvim中使用&quot;%&quot;操作，即可在各类配对的符号（针对verilog/systemverilog代码）中跳转。 字体缩放 zoom.vim放入plugin文件夹即可使用。使用&quot;+“和”-&quot;进行Gvim字体大小的缩放。 RTLTree 暂未使用，这里介绍一下找到的相关资料。主要想弄一个RTL结构树类型的插件。在搜索过程中找到了如下资料： vtags3.0: vim/gvim中进行verilog语言信号追踪、显示拓扑插件，最新3.0版 ，然后根据这个找到了原版在vimscript上的原版vtags : verdi like, verilog code signal trace and show topo script。试了半天之后发现指导书均基于linux，貌似在windows下Gvim没法用，故放弃。 在这个自动化脚本里也有ctag_gen文件，作者也是用这个生成ctags，然后形成rtltree。尝试了发现不行，不知具体原因。 在基于GVim搭建Verilog开发环境中介绍了universal-ctags的使用，使用 git-bash ctags -R --languages=Verilog /path/to/the/code 也成功生成了ctags，只是未尝试结合verilog_systemverilog的模块跳转功能。感觉这个功能影响不大，因为这个依然没有RTLTree显示的功能。 最新进展（2020-2-28）：脚本ctags这个可以在windows下使用，需要perl。如果有git-bash很简单，git自带perl。可以用perl -v 查看自己的bash是否带perl。将所有.v文件和ctags_gen文件放到一个文件夹下，在git-bash中用perl输入： 1perl ctags_gen *.v 这样就会在文件夹下生成一个tag文件。这样在Gvim中使用:Rtltree命令即可通过NERDTree插件查看Rtltree结构。注意这个脚本不是很稳定，有些时候调用会出问题。建议还是使用IDE，不在编辑器里使用。 插件设置 安装一些Verilog的Gvim插件。 Vundle插件管理 Vundle安装参考基于GVim搭建Verilog开发环境以及其源网站VundleVim/Vundle.vim。vimrc添加配置如下： 12345678910111213141516171819202122232425&quot; =============================================================&quot; 插件设置&quot; =============================================================&quot; 设置运行路径，注意新建系统变量VIM指向Gvim的安装目录if(has(&#x27;win32&#x27;) || has(&#x27;win64&#x27;)) set rtp+=$VIM/vimfiles/bundle/Vundle.vim let path=&#x27;$VIM/vimfiles/bundle&#x27;else set rtp+=~/.vim/bundle/Vundle.vim let path=&#x27;~/.vim/bundle&#x27;endif&quot; -----------------------插件列表------------------------------call vundle#begin(&#x27;$VIM/vimfiles/bundle&#x27;)&quot;使用Vundle管理插件Plugin &#x27;VundleVim/Vundle.vim&#x27;&quot;多插件列表Plugin &#x27;AutoComplPop&#x27; &quot;自动补全窗口弹出Plugin &#x27;vim-syntastic/syntastic&#x27; &quot;语法检查call vundle#end()&quot;允许插件 filetype plugin on 注意#begin位置那里要加入路径，不然可能生成两个bundle文件夹安装插件，因为默认在.vim文件夹下自建插件文件夹。 配置完成后启动Gvim，在Gvim中输入运行 :PluginInstall 安装插件。运行:PluginList查看安装了的插件。 若要卸载插件，先在vimrc中删除Plugin，然后启动Gvim，运行:PluginClean即可卸载插件。 这样的安装和卸载方法可以减少复制粘贴文件的麻烦，便于管理使用的插件。 AutoComplPop自动补全 输入时自动弹出补全窗口。直接使用Vundle安装即可。参考vim-scripts/AutoComplPop。根据网上的说法，YCM集成了多个插件，功能上应该更好。但鉴于本人暂时不需要复杂的自动补全，故没有选择YCM。 Syntastic代码检查 Vim之代码异步检测插件 ALE、 Vim插件之ale中阐述主要有三种代码检查插件 Syntastic Neomake ALE 其中ALE为异步检测，效果最好，但是需要vim8以上的版本。本人之前一直使用的是Vim7.3，编译的要求也不高，只做简单的规则检查，所以暂时用的老版的syntastic。 使用Vundle安装syntastic过程中可能有故障，关闭打开的cmd窗口，忽略那些错误提示完成安装即可。 另外需要给syntastic配置Linter，这里使用iverilog。windows版本下载：Icarus Verilog for Windows。安装后需要将iverilog加入系统变量$PATH中，这样就可以在命令行里调用iverilog命令了。参考Windows 10下配置和使用Icarus Verilog (iverilog)和GTKWave和Windows上使用iverilog+gtkwave仿真 配置vimrc中的syntastic不正确会有类似故障信息如下： 12345E484: Cannot open file &#x2F;tmp&#x2F;vnmSZpx&#x2F;4 Error detected while processing function SyntasticInfo..310..309..247: line 3: E171: Missing :endif Error detected while processing function SyntasticInfo..310: Google后发现 Error messages when enabling syntastic #1384以及vim-syntastic/syntastic的FAQ的4.1里都有说，应该是shellslash的平台问题，syntastic_shell设置成git-bash后正常。但后来在syntastic调用git-bash一阵子再使用时出现故障 1bash: &#x2F;c: Is a directory &#x2F;usr&#x2F;bin&#x2F;bash: Exit 126. 切换回命令行又可以正常使用。原因未知。 修改的vimrc配置： 123456789101112131415161718192021222324252627&quot;语法检查插件配置set statusline+&#x3D;%#warningmsg#set statusline+&#x3D;%&#123;SyntasticStatuslineFlag()&#125;set statusline+&#x3D;%*&quot;显示消息气泡let g:syntastic_enable_balloons &#x3D; 1&quot;let g:syntastic_always_populate_loc_list &#x3D; 1&quot;不自动进行代码检查let g:syntastic_auto_loc_list &#x3D; 1let g:syntastic_check_on_open &#x3D; 0let g:syntastic_check_on_wq &#x3D; 0let g:syntastic_mode_map &#x3D; &#123; \\ &quot;mode&quot;: &quot;passive&quot;, \\ &quot;active_filetypes&quot;: [&quot;&quot;], \\ &quot;passive_filetypes&quot;: [&quot;verilog&quot;] &#125; &quot; 设置linter为iverilog,这里需要在系统变量PATH中添加iverilog的位置，这样shell才能识别iverilog指令let g:syntastic_verilog_checkers &#x3D; [&#39;iverilog&#39;]&quot; 设置shell路径，注意这玩意不接受cmd.exe这种windows的shell，不设置就有问题(????????????????????????????????)&quot; let g:syntastic_shell &#x3D; &amp;shellnnoremap check :SyntasticCheck&lt;CR&gt; 其中，mode_map设置主要为了关闭保存文件自动代码检查的功能。另外映射了check为代码检查的快捷键。代码编写完成后运行:SyntasticCheck或直接输入check即进行检查，效果如下： 之后换新版Gvim考虑把代码检查换成ALE。 终版vimrc配置 按照之前需要的添加部分配置，然后删除了部分代码（添加always块和头部已经加入了自动化脚本的功能）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287&quot; =============================================================&quot; Decription: 用于编写Verilog的vimrc文件，for windows&quot; Ver：1.1&quot; Maintainer: Honk&quot; Date: 2020-2-19&quot; =============================================================&quot; =============================================================&quot; 基础设置&quot; =============================================================set nocompatible &quot;关闭vi兼容模式source $VIMRUNTIME/vimrc_example.vimsource $VIMRUNTIME/mswin.vimbehave mswin &quot;部分按键按照windows模式操作，解决crtl+c、ctrl+v、ctrl+a等windows下的快捷键 &quot;Windows Gvim 默认配置set diffexpr=MyDiff()function! MyDiff() let opt = &#x27;-a --binary &#x27; if &amp;diffopt =~ &#x27;icase&#x27; | let opt = opt . &#x27;-i &#x27; | endif if &amp;diffopt =~ &#x27;iwhite&#x27; | let opt = opt . &#x27;-b &#x27; | endif let arg1 = v:fname_in if arg1 =~ &#x27; &#x27; | let arg1 = &#x27;&quot;&#x27; . arg1 . &#x27;&quot;&#x27; | endif let arg2 = v:fname_new if arg2 =~ &#x27; &#x27; | let arg2 = &#x27;&quot;&#x27; . arg2 . &#x27;&quot;&#x27; | endif let arg3 = v:fname_out if arg3 =~ &#x27; &#x27; | let arg3 = &#x27;&quot;&#x27; . arg3 . &#x27;&quot;&#x27; | endif let eq = &#x27;&#x27; if $VIMRUNTIME =~ &#x27; &#x27; if &amp;sh =~ &#x27;\\&lt;cmd&#x27; let cmd = &#x27;&quot;&quot;&#x27; . $VIMRUNTIME . &#x27;\\diff&quot;&#x27; let eq = &#x27;&quot;&#x27; else let cmd = substitute($VIMRUNTIME, &#x27; &#x27;, &#x27;&quot; &#x27;, &#x27;&#x27;) . &#x27;\\diff&quot;&#x27; endif else let cmd = $VIMRUNTIME . &#x27;\\diff&#x27; endif silent execute &#x27;!&#x27; . cmd . &#x27; &#x27; . opt . arg1 . &#x27; &#x27; . arg2 . &#x27; &gt; &#x27; . arg3 . eqendfunction&quot; =============================================================&quot; 成对标签设置&quot; =============================================================source $VIMRUNTIME/macros/matchit.vimlet b:match_ignorecase=0let b:match_words= \\ &#x27;\\&lt;begin\\&gt;:\\&lt;end\\&gt;,&#x27; . \\ &#x27;\\&lt;if\\&gt;:\\&lt;else\\&gt;,&#x27; . \\ &#x27;\\&lt;module\\&gt;:\\&lt;endmodule\\&gt;,&#x27; . \\ &#x27;\\&lt;class\\&gt;:\\&lt;endclass\\&gt;,&#x27; . \\ &#x27;\\&lt;program\\&gt;:\\&lt;endprogram\\&gt;,&#x27; . \\ &#x27;\\&lt;clocking\\&gt;:\\&lt;endclocking\\&gt;,&#x27; . \\ &#x27;\\&lt;property\\&gt;:\\&lt;endproperty\\&gt;,&#x27; . \\ &#x27;\\&lt;sequence\\&gt;:\\&lt;endsequence\\&gt;,&#x27; . \\ &#x27;\\&lt;package\\&gt;:\\&lt;endpackage\\&gt;,&#x27; . \\ &#x27;\\&lt;covergroup\\&gt;:\\&lt;endgroup\\&gt;,&#x27; . \\ &#x27;\\&lt;primitive\\&gt;:\\&lt;endprimitive\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;interface\\&gt;:\\&lt;endinterface\\&gt;,&#x27; . \\ &#x27;\\&lt;function\\&gt;:\\&lt;endfunction\\&gt;,&#x27; . \\ &#x27;\\&lt;task\\&gt;:\\&lt;endtask\\&gt;,&#x27; . \\ &#x27;\\&lt;for\\&gt;:\\&lt;endfor\\&gt;,&#x27; . \\ &#x27;\\&lt;while\\&gt;:\\&lt;endwhile\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;case\\&gt;\\|\\&lt;casex\\&gt;\\|\\&lt;casez\\&gt;:\\&lt;endcase\\&gt;,&#x27; . \\ &#x27;\\&lt;fork\\&gt;:\\&lt;join\\&gt;\\|\\&lt;join_any\\&gt;\\|\\&lt;join_none\\&gt;,&#x27; . \\ &#x27;`ifdef\\&gt;:`else\\&gt;:`endif\\&gt;,&#x27;&quot; =============================================================&quot; 插件设置&quot; =============================================================&quot; 设置运行路径，注意新建系统变量VIM指向Gvim的安装目录if(has(&#x27;win32&#x27;) || has(&#x27;win64&#x27;)) set rtp+=$VIM/vimfiles/bundle/Vundle.vim let path=&#x27;$VIM/vimfiles/bundle&#x27;else set rtp+=~/.vim/bundle/Vundle.vim let path=&#x27;~/.vim/bundle&#x27;endif&quot; -----------------------插件列表------------------------------call vundle#begin(&#x27;$VIM/vimfiles/bundle&#x27;)&quot;使用Vundle管理插件Plugin &#x27;VundleVim/Vundle.vim&#x27;&quot;多插件列表Plugin &#x27;AutoComplPop&#x27; &quot;自动补全窗口弹出Plugin &#x27;vim-syntastic/syntastic&#x27; &quot;语法检查call vundle#end()&quot;允许插件 filetype plugin on&quot;语法检查插件配置set statusline+=%#warningmsg#set statusline+=%&#123;SyntasticStatuslineFlag()&#125;set statusline+=%*&quot;显示消息气泡let g:syntastic_enable_balloons = 1&quot;let g:syntastic_always_populate_loc_list = 1&quot;不自动进行代码检查let g:syntastic_auto_loc_list = 1let g:syntastic_check_on_open = 0let g:syntastic_check_on_wq = 0let g:syntastic_mode_map = &#123; \\ &quot;mode&quot;: &quot;passive&quot;, \\ &quot;active_filetypes&quot;: [&quot;&quot;], \\ &quot;passive_filetypes&quot;: [&quot;verilog&quot;] &#125; &quot; 设置linter为iverilog,这里需要在系统变量PATH中添加iverilog的位置，这样shell才能识别iverilog指令let g:syntastic_verilog_checkers = [&#x27;iverilog&#x27;]&quot; 设置shell路径，注意这玩意不接受cmd.exe这种windows的shell，不设置就有问题(????????????????????????????????)&quot; let g:syntastic_shell = &amp;shellnnoremap check :SyntasticCheck&lt;CR&gt;&quot; =============================================================&quot; 界面设置&quot; =============================================================set guifont=courier_new:b:h16 &quot;windows设定字体风格字号&quot;set guifont=Courier\\ 100\\ Pitch &quot;linux 设定字体风格字号set number &quot;显示行号set background=light &quot;背景colorscheme desert &quot;设定配色方案syntax on &quot;语法高亮highlight Pmenu guibg=darkgrey guifg=white &quot;修改自动补全窗口的配色highlight PmenuSel guibg=lightgrey guifg=white&quot; =============================================================&quot; tab键设置&quot; =============================================================set expandtab &quot;tab自动转换空格set softtabstop=4 &quot;使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot;设定tab长度为4set shiftwidth=4 &quot;设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4&quot;set autoindent &quot;设定自动缩进&quot; =============================================================&quot; 其他设置&quot; =============================================================&quot;set ignorecase &quot;搜索时忽略大小写&quot;set ignorecase smartcase &quot;搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感&quot; ----------Vim打开文件时，会出现另一个同名的备份文件----------set nowritebackup &quot;写入期间不进行备份&quot;set writebackup &quot;写入期间备份set nobackup &quot;不保存备份&quot;set backup &quot;保存备份&quot; -------------------------------------------------------------set helplang=en &quot;设置英文帮助&quot;set helplang=cn &quot;设置中文帮助set directory=$VIMHOME\\swp,.set showcmd &quot;显示在最右下角展示最近输入的命令set backspace=indent,eol,start &quot;不设定在插入状态下无法用退格键和delete键删除回车符set foldclose=all &quot;设置为自动关闭折叠set fileformats=dos &quot;消除文件格式不正确的出现^M&quot;set encoding=utf-8 &quot;解决中文乱码set termencoding=utf-8 set fileencodings=utf-8,chinese,latin-1 &quot; -------------------------------------------------------------if has(&quot;win32&quot;) set fileencoding=chinese else set fileencoding=utf-8 endif &quot;language messages zh_CN.utf-8&quot; =============================================================&quot; IDE设置&quot; =============================================================&quot; -------------------------文件窗口----------------------------&quot;creat tagsset tags=tags;set autochdir&quot;窗口管理let Tlist_Show_One_File=1let Tlist_Exit_OnlyWindow=1&quot;let g:winManagerWindowLayout=&#x27;FileExplorer|TagList&#x27;let g:winManagerWindowLayout=&#x27;FileExplorer&#x27;nmap vp :WMToggle&lt;cr&gt;&quot;多文件编辑let g:miniBufExplMapCTabSwitchBufs=1let g:miniBufExplMapWindowsNavVim=1let g:miniBufExplMapWindowNavArrows=1let g:miniBufExplorerMoreThanOne=1&quot;grepnnoremap &lt;silent&gt; &lt;F10&gt; :Grep&lt;CR&gt;&quot; -------------------------编辑vimrc--------------------------&quot;按F4或输入ee编辑_vimrc:map &lt;F4&gt; :source $VIMHOME/_vimrc&lt;cr&gt;:w!&lt;cr&gt;:map ,ee :e $VIMHOME/_vimrc&lt;cr&gt;&quot; ------------------------------------------------------------cnoremap &lt;silent&gt; sp :sp&lt;cr&gt;cnoremap &lt;silent&gt; vp :vsplit&lt;cr&gt;&quot;:map gb :bd&lt;cr&gt;&lt;F4&gt; &quot;键盘键的映射，将gb快捷键映射为:bd回车键。即新建一个vim窗口。&quot; =============================================================&quot; 自定义设置&quot; nore 表示非递归&quot; n 表示在普通模式下生效&quot; v 表示在可视模式下生效&quot; i 表示在插入模式下生效&quot; c 表示在命令行模式下生效&quot; =============================================================&quot; -------------------------例化变量----------------------------&quot;F2例化光标选中变量(命令模式下):map &lt;F2&gt; ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ .\\1 (\\1 ),/&lt;cr&gt;*^24ldw24ldw`sj&quot; -------------------------生成时间----------------------------&quot;F2生成当前时间,格式为 2019/11/20 23:39:15(插入模式下)&quot;:imap &lt;F2&gt; &lt;C-R&gt;=strftime(&quot;%c&quot;)&lt;CR&gt;&quot;F2生成当前时间,格式为 2019/11/20(插入模式下):imap &lt;F2&gt; &lt;C-R&gt;=strftime(&quot;%x&quot;)&lt;CR&gt;&quot; ------------------------产生代码段---------------------------&quot;添加reg/wire注释:map ;cr i&lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi//========================================================================\\&lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi// =========== Define Parameter and Internal signals =========== &lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi//========================================================================/&lt;ESC&gt;&quot;添加MAIN CODE注释:map ;cc i&lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi//=============================================================================&lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi//************** Main Code **************&lt;cr&gt;&lt;space&gt;&lt;ESC&gt;0dwi//=============================================================================&lt;ESC&gt;&quot; ----------------------端口/变量声明--------------------------&quot;选中单词声明为wire:map ;dw ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/wire \\1;/&lt;cr&gt;&lt;F8&gt;e*N`sj&quot;选中单词声明为reg:map ;dr ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/reg \\1;/&lt;cr&gt;&lt;F8&gt;e*N`sj&quot;选中单词声明为input:map ;i ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ input \\1,/&lt;cr&gt;&lt;F7&gt;e*N`sj&quot;选中单词声明为output wire:map ;ow ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ output wire \\1,/&lt;cr&gt;&lt;F7&gt;bb*N`sj&quot;选中单词声明为output reg:map ;or ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ output reg \\1,/&lt;cr&gt;&lt;F7&gt;bb*N`sj&quot; ------------------------对齐格式---------------------------&quot;调整格式以便对齐（例化后的）:map &lt;F6&gt; :s/^ *\\./ ./&lt;cr&gt;^f(i &lt;ESC&gt;f)i &lt;ESC&gt;^24ldw24ldwa &lt;ESC&gt;hdwj&quot;调整module定义中的变量，逗号和注释的位置:map &lt;F7&gt; 0f,bi &lt;ESC&gt;^24ldwf,i &lt;ESC&gt;^48ldwa &lt;ESC&gt;dw^j&quot;调整reg，wire所在行的变量，逗号和注释的位置:map &lt;F8&gt; 0f;bi &lt;ESC&gt;032ldwf;i &lt;ESC&gt;064ldwa &lt;ESC&gt;dw^j&quot;调整module定义中的逗号和注释的位置（定义中不包含input、output时使用）:map &lt;F9&gt; 0f,i &lt;ESC&gt;056ldwa &lt;ESC&gt;dw&lt;ESC&gt;^j&quot; --------------------------其他-----------------------------&quot;:map &lt;F11&gt; :s/$/ /&lt;cr&gt;j&quot;:map &lt;F12&gt; :s/^\\([^ ]*\\)/NET &quot;\\1&quot; IOSTANDARD = LVTTL \\| LOC = &quot;&quot; ;/&lt;cr&gt;028ldw06l*Nj&quot;:map ;f :s/\\([0-9]\\) *&quot;/\\1&quot;/g&lt;cr&gt;j&quot;:map &lt;F12&gt; :.w! F:\\software_for_FPGA\\eg.v&lt;cr&gt;:source F:\\software_for_FPGA\\eg.v&lt;cr&gt;&quot;删除TAB&quot;:map ;t :%s/\\t/ /g&lt;cr&gt;:w&lt;cr&gt;&quot;产生U_DLY&quot;:imap &lt;F4&gt; &lt;space&gt;&lt;= #U_DLY &quot;删除:map ;m :%s/:autocmd Bufread :source $VIMHOME/_vimrc&lt;cr&gt;:w!&lt;cr&gt;&quot;====restore your cursor position in a file over several editing sessionsau BufReadPost * if line(&quot;&#x27;\\&quot;&quot;) &gt; 0|if line(&quot;&#x27;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &#x27;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endif&quot; =============================================================&quot; RTLTree&quot; 暂未使用，暂时关闭&quot; =============================================================let t:RtlTreeVlogDefine = 0&quot;map &lt;F4&gt; :NERDTree&lt;CR&gt;&quot;map &lt;F5&gt; :RtlTree&lt;CR&gt; 其他设置 还有一些网上查到的相关配置文件，但是没有暂时还没有使用的，暂时列在下面作为备用。以后学习新东西需要用时方便参考。 中文帮助 Vim自带help文档可以切换为中文，参考链接如下： Vim帮助文档首页 Vim中文帮助文档网页版 下载链接 下载完成，按步骤安装。安装完成后打开vim，输入：help ，这时vim中的help信息已经是中文了。 当然，可以通过下面命令来切换帮助语言。 12set helplang=cn &quot;设置中文帮助set helplang=en &quot;设置英文帮助 参考 部分发现了但是未用到的配置资料。 提高Verilog和UVM testbench coding效率的利器 Verilog部分 自动产生端口信号列表； 自动产生信号声明； 自动例化（能够识别例化之后连接的变更，优于emacs） 自动产生一些有规律的代码（类似generate语句） 用户定义参数化模版 UVM部分 自动产生interface 自动产生uvm_field_* 各种uvm类的模版 vtags : verdi like, verilog code signal trace and show topo script 总结 为了在Windows下使用Gvim折腾了这么久，确实能得出一个结论：Linux开发比Windows方便很多。 最新v8.2版Gvim修改（2020-02-26 23:15:25 创建） 继续之前Gvim搭建Verilog编程环境的基础上，修改了部分配置和插件，针对最新的Gvim-v8.2。 vimrc更改 主要把代码段功能全部搬移到了automatic.vim文件里。另外对对齐操作进行了修改，使得input/output和reg/wire等的对齐也是一致的。另外autoinst的格式与对齐操作的格式的不一样，这个没去改，要用的时候直接重新对齐一下就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270&quot; =============================================================&quot; Decription: 用于Verilog的vimrc文件，for windows&quot; Maintainer: Honk&quot; Date: 2020-2-26&quot; =============================================================&quot; =============================================================&quot; 基础设置&quot; =============================================================set nocompatible &quot;关闭vi兼容模式source $VIMRUNTIME/vimrc_example.vim &quot; Vim with all enhancementssource $VIMRUNTIME/mswin.vim &quot; Remap a few keys for Windows behavior 部分按键按照windows模式操作，解决crtl+c、ctrl+v、ctrl+a等windows下的快捷键behave mswin &quot; Mouse behavior (the Windows way) 鼠标操作&quot; Use the internal diff if available.&quot; Otherwise use the special &#x27;diffexpr&#x27; for Windows.if &amp;diffopt !~# &#x27;internal&#x27; set diffexpr=MyDiff()endiffunction MyDiff() let opt = &#x27;-a --binary &#x27; if &amp;diffopt =~ &#x27;icase&#x27; | let opt = opt . &#x27;-i &#x27; | endif if &amp;diffopt =~ &#x27;iwhite&#x27; | let opt = opt . &#x27;-b &#x27; | endif let arg1 = v:fname_in if arg1 =~ &#x27; &#x27; | let arg1 = &#x27;&quot;&#x27; . arg1 . &#x27;&quot;&#x27; | endif let arg1 = substitute(arg1, &#x27;!&#x27;, &#x27;\\!&#x27;, &#x27;g&#x27;) let arg2 = v:fname_new if arg2 =~ &#x27; &#x27; | let arg2 = &#x27;&quot;&#x27; . arg2 . &#x27;&quot;&#x27; | endif let arg2 = substitute(arg2, &#x27;!&#x27;, &#x27;\\!&#x27;, &#x27;g&#x27;) let arg3 = v:fname_out if arg3 =~ &#x27; &#x27; | let arg3 = &#x27;&quot;&#x27; . arg3 . &#x27;&quot;&#x27; | endif let arg3 = substitute(arg3, &#x27;!&#x27;, &#x27;\\!&#x27;, &#x27;g&#x27;) if $VIMRUNTIME =~ &#x27; &#x27; if &amp;sh =~ &#x27;\\&lt;cmd&#x27; if empty(&amp;shellxquote) let l:shxq_sav = &#x27;&#x27; set shellxquote&amp; endif let cmd = &#x27;&quot;&#x27; . $VIMRUNTIME . &#x27;\\diff&quot;&#x27; else let cmd = substitute($VIMRUNTIME, &#x27; &#x27;, &#x27;&quot; &#x27;, &#x27;&#x27;) . &#x27;\\diff&quot;&#x27; endif else let cmd = $VIMRUNTIME . &#x27;\\diff&#x27; endif let cmd = substitute(cmd, &#x27;!&#x27;, &#x27;\\!&#x27;, &#x27;g&#x27;) silent execute &#x27;!&#x27; . cmd . &#x27; &#x27; . opt . arg1 . &#x27; &#x27; . arg2 . &#x27; &gt; &#x27; . arg3 if exists(&#x27;l:shxq_sav&#x27;) let &amp;shellxquote=l:shxq_sav endifendfunction&quot; =============================================================&quot; 界面设置&quot; =============================================================set guifont=courier_new:b:h16 &quot;windows设定字体风格字号set number &quot;显示行号set background=light &quot;背景colorscheme desert &quot;设定配色方案syntax on &quot;语法高亮highlight Pmenu guibg=darkgrey guifg=white &quot;修改自动补全窗口的配色highlight PmenuSel guibg=darkblue guifg=whiteset nofoldenable &quot;关闭折叠&quot; =============================================================&quot; tab键设置&quot; =============================================================set expandtab &quot;tab自动转换空格set softtabstop=4 &quot;使得按退格键时可以一次删掉 4 个空格set tabstop=4 &quot;设定tab长度为4set shiftwidth=4 &quot;设定 &lt;&lt; 和 &gt;&gt; 命令移动时的宽度为 4&quot;set autoindent &quot;设定自动缩进&quot; =============================================================&quot; 其他设置&quot; =============================================================&quot;set ignorecase &quot;搜索时忽略大小写&quot;set ignorecase smartcase &quot;搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感&quot; ----------Vim打开文件时，会出现另一个同名的备份文件----------set nowritebackup &quot;写入期间不进行备份&quot;set writebackup &quot;写入期间备份set nobackup &quot;不保存备份&quot;set backup &quot;保存备份set noundofile &quot;不保存撤销文件&quot; -------------------------语言问题----------------------------set helplang=en &quot;设置英文帮助&quot;set helplang=cn &quot;设置中文帮助set directory=$VIMHOME\\swp,.set showcmd &quot;显示在最右下角展示最近输入的命令set backspace=indent,eol,start &quot;不设定在插入状态下无法用退格键和delete键删除回车符set foldclose=all &quot;设置为自动关闭折叠set fileformats=dos &quot;消除文件格式不正确的出现^M&quot;set encoding=utf-8 &quot;解决中文乱码set termencoding=utf-8 set fileencodings=utf-8,chinese,latin-1 &quot; -------------------------------------------------------------if has(&quot;win32&quot;) set fileencoding=chinese else set fileencoding=utf-8 endif &quot; =============================================================&quot; 插件设置&quot; =============================================================&quot; 设置运行路径，注意新建系统变量VIM指向Gvim的安装目录if(has(&#x27;win32&#x27;) || has(&#x27;win64&#x27;)) set rtp+=$VIM/vimfiles/bundle/Vundle.vim let path=&#x27;$VIM/vimfiles/bundle&#x27;else set rtp+=~/.vim/bundle/Vundle.vim let path=&#x27;~/.vim/bundle&#x27;endif&quot; -----------------------插件列表------------------------------call vundle#begin(&#x27;$VIM/vimfiles/bundle&#x27;)&quot;使用Vundle管理插件Plugin &#x27;VundleVim/Vundle.vim&#x27;&quot;多插件列表Plugin &#x27;AutoComplPop&#x27; &quot;自动补全窗口弹出Plugin &#x27;preservim/nerdtree&#x27; &quot;显示当前路径目录树结构&quot;Plugin &#x27;dense-analysis/ale&#x27; &quot;ALE-Asynchronous Lint Engine语法检查Plugin &#x27;vim-syntastic/syntastic&#x27; &quot;syntastic语法检查Plugin &#x27;vim-airline/vim-airline&#x27; &quot;状态栏美化call vundle#end()&quot;总是打开Location List（相当于QuickFix）窗口，如果你发现syntastic因为与其他插件冲突而经常崩溃，将下面选项置0let g:syntastic_always_populate_loc_list = 1&quot;不自动进行代码检查let g:syntastic_auto_loc_list = 1let g:syntastic_check_on_open = 0let g:syntastic_check_on_wq = 0let g:syntastic_mode_map = &#123; \\ &quot;mode&quot;: &quot;passive&quot;, \\ &quot;active_filetypes&quot;: [&quot;&quot;], \\ &quot;passive_filetypes&quot;: [&quot;verilog&quot;] &#125; &quot; 设置linter为iveriloglet g:syntastic_verilog_checkers = [&#x27;iverilog&#x27;]&quot;允许插件 filetype plugin on&quot; =============================================================&quot; 成对标签设置&quot; =============================================================source $VIMRUNTIME/macros/matchit.vimlet b:match_ignorecase=0let b:match_words= \\ &#x27;\\&lt;begin\\&gt;:\\&lt;end\\&gt;,&#x27; . \\ &#x27;\\&lt;if\\&gt;:\\&lt;else\\&gt;,&#x27; . \\ &#x27;\\&lt;module\\&gt;:\\&lt;endmodule\\&gt;,&#x27; . \\ &#x27;\\&lt;class\\&gt;:\\&lt;endclass\\&gt;,&#x27; . \\ &#x27;\\&lt;program\\&gt;:\\&lt;endprogram\\&gt;,&#x27; . \\ &#x27;\\&lt;clocking\\&gt;:\\&lt;endclocking\\&gt;,&#x27; . \\ &#x27;\\&lt;property\\&gt;:\\&lt;endproperty\\&gt;,&#x27; . \\ &#x27;\\&lt;sequence\\&gt;:\\&lt;endsequence\\&gt;,&#x27; . \\ &#x27;\\&lt;package\\&gt;:\\&lt;endpackage\\&gt;,&#x27; . \\ &#x27;\\&lt;covergroup\\&gt;:\\&lt;endgroup\\&gt;,&#x27; . \\ &#x27;\\&lt;primitive\\&gt;:\\&lt;endprimitive\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;interface\\&gt;:\\&lt;endinterface\\&gt;,&#x27; . \\ &#x27;\\&lt;function\\&gt;:\\&lt;endfunction\\&gt;,&#x27; . \\ &#x27;\\&lt;task\\&gt;:\\&lt;endtask\\&gt;,&#x27; . \\ &#x27;\\&lt;for\\&gt;:\\&lt;endfor\\&gt;,&#x27; . \\ &#x27;\\&lt;while\\&gt;:\\&lt;endwhile\\&gt;,&#x27; . \\ &#x27;\\&lt;specify\\&gt;:\\&lt;endspecify\\&gt;,&#x27; . \\ &#x27;\\&lt;generate\\&gt;:\\&lt;endgenerate\\&gt;,&#x27; . \\ &#x27;\\&lt;case\\&gt;\\|\\&lt;casex\\&gt;\\|\\&lt;casez\\&gt;:\\&lt;endcase\\&gt;,&#x27; . \\ &#x27;\\&lt;fork\\&gt;:\\&lt;join\\&gt;\\|\\&lt;join_any\\&gt;\\|\\&lt;join_none\\&gt;,&#x27; . \\ &#x27;`ifdef\\&gt;:`else\\&gt;:`endif\\&gt;,&#x27; &quot; =============================================================&quot; 窗口管理设置&quot; =============================================================&quot;creat tagsset tags=tags;set autochdir&quot;窗口管理let Tlist_Show_One_File=1let Tlist_Exit_OnlyWindow=1&quot;let g:winManagerWindowLayout=&#x27;FileExplorer|TagList&#x27;let g:winManagerWindowLayout=&#x27;FileExplorer&#x27;nmap vp :WMToggle&lt;cr&gt;&quot;多文件编辑let g:miniBufExplMapCTabSwitchBufs=1let g:miniBufExplMapWindowsNavVim=1let g:miniBufExplMapWindowNavArrows=1let g:miniBufExplorerMoreThanOne=1&quot;grepnnoremap &lt;silent&gt; &lt;F10&gt; :Grep&lt;CR&gt;&quot; =============================================================&quot; 自定义设置&quot; nore 表示非递归&quot; n 表示在普通模式下生效&quot; v 表示在可视模式下生效&quot; i 表示在插入模式下生效&quot; c 表示在命令行模式下生效&quot; =============================================================&quot; -------------------------编辑vimrc--------------------------&quot;按F4或输入ee编辑_vimrc:map &lt;F4&gt; :source $VIMHOME/_vimrc&lt;cr&gt;:w!&lt;cr&gt;:map ,ee :e $VIMHOME/_vimrc&lt;cr&gt;&quot; ------------------------------------------------------------cnoremap &lt;silent&gt; sp :sp&lt;cr&gt;cnoremap &lt;silent&gt; vp :vsplit&lt;cr&gt;&quot;:map gb :bd&lt;cr&gt;&lt;F4&gt; &quot;键盘键的映射，将gb快捷键映射为:bd回车键。即新建一个vim窗口。&quot; -------------------------例化变量----------------------------&quot;F2例化光标选中变量(命令模式下):map &lt;F2&gt; ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ .\\1 (\\1 ),/&lt;cr&gt;*^24ldw24ldw`sj&quot; ----------------------端口/变量声明--------------------------&quot;选中单词声明为wire:map ;dw ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ wire \\1;/&lt;cr&gt;&lt;F8&gt;e*N`sj&quot;选中单词声明为reg:map ;dr ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ reg \\1;/&lt;cr&gt;&lt;F8&gt;e*N`sj&quot;选中单词声明为input:map ;i ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ input \\1,/&lt;cr&gt;&lt;F7&gt;e*N`sj&quot;选中单词声明为output wire:map ;ow ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ output wire \\1,/&lt;cr&gt;&lt;F7&gt;bb*N`sj&quot;选中单词声明为output reg:map ;or ebmsd^:.s/^ *\\([a-zA-Z][a-zA-Z0-9_]*\\).*$/ output reg \\1,/&lt;cr&gt;&lt;F7&gt;bb*N`sj&quot; ------------------------对齐格式---------------------------&quot;调整格式以便对齐（例化后的）:map &lt;F6&gt; :s/^ *\\./ ./&lt;cr&gt;^f(i &lt;ESC&gt;f)i &lt;ESC&gt;^24ldw24ldwa &lt;ESC&gt;hdwj&quot;调整module定义中的变量，逗号和注释的位置:map &lt;F7&gt; 0f,bi &lt;ESC&gt;^24ldwf,i &lt;ESC&gt;^48ldwa &lt;ESC&gt;dw^j&quot;调整reg，wire所在行的变量，逗号和注释的位置:map &lt;F8&gt; 0f;bi &lt;ESC&gt;028ldwf;i &lt;ESC&gt;052ldwa &lt;ESC&gt;dw^j&quot;调整module定义中的逗号和注释的位置（定义中不包含input、output时使用）:map &lt;F9&gt; 0f,i &lt;ESC&gt;056ldwa &lt;ESC&gt;dw&lt;ESC&gt;^j&quot; -------------------------生成时间----------------------------&quot;F2生成当前时间,格式为 2019/11/20 23:39:15(插入模式下)&quot;:imap &lt;F2&gt; &lt;C-R&gt;=strftime(&quot;%c&quot;)&lt;CR&gt;&quot;F2生成当前时间,格式为 2019/11/20(插入模式下):imap &lt;F2&gt; &lt;C-R&gt;=strftime(&quot;%x&quot;)&lt;CR&gt;&quot; -------------------------其他设置----------------------------&quot;删除TAB &quot;:map ;t :%s/\\t/ /g&lt;cr&gt;:w&lt;cr&gt;&quot;TAB 转化为空格:map ;t :retab&lt;cr&gt;&quot;产生U_DLY&quot;:imap &lt;F4&gt; &lt;space&gt;&lt;= #U_DLY&quot;删除:map ;m :%s/:autocmd Bufread :source $VIMHOME/_vimrc&lt;cr&gt;:w!&lt;cr&gt;&quot;====restore your cursor position in a file over several editing sessionsau BufReadPost * if line(&quot;&#x27;\\&quot;&quot;) &gt; 0|if line(&quot;&#x27;\\&quot;&quot;) &lt;= line(&quot;$&quot;)|exe(&quot;norm &#x27;\\&quot;&quot;)|else|exe &quot;norm $&quot;|endif|endiflet t:RtlTreeVlogDefine = 0&quot;map &lt;F4&gt; :NERDTree&lt;CR&gt;&quot;map &lt;F5&gt; :RtlTree&lt;CR&gt; 脚本更改 针对automatic.vim做了部分修改: 添加一键生成三段式状态机（快捷键fsm）； 头文件生成快捷键由hd改为header（鉴于hd可能误操作）； 删掉了check快捷键（使用:SyntasticCheck命令直接检查，主要是点击后用TAB也很方便，不太需要map这个快捷键）； 生成主代码和wire/reg部分注释的快捷键由vimrc搬移到脚本中（快捷键;cr和;cc）。 插件更改（2020.3.6更新） 原计划更改代码检查工具从Syntastic变为异步的ALE，但使用Vundle安装ALE并配置之后，可以在ALEInfo看到Liner报出来的故障信息（且是多次执行的结果，表示其在异步调用Linter，且调用成功），但在Vim界面上没有任何标识，原因未知，进入iverilog.vim中echom其匹配error/warning/syntaxerr消息的那个函数结果好像是空的，不知道是脚本哪里有问题。在google和百度搜索了半天后无解，遂放弃。但在安装ALE中顺便安装了NERDTree和airline-vim，后来也没有再卸载。 NERDTree：文件结构树 airline-vim：状态栏美化 安装过程依旧使用Vundle插件管理。 VisIncr（新添加）：列操作，添加递增递减一列数字 部分计划 为了学习脚本中的ctag和调用RTLTree，以后找机会学一下Perl 部分功能问题在windows下没有解决方案，但是linux下有，可以一试。 部分有用链接 学习过程中还搜索到了一些相关的可用功能，因为跟现有功能重复，所以没有使用。在此记录留作备份。 在Vim中集成emacs下的verilog-mode功能 这才是用Gvim写Verilog的正确方式 Vim Syntax Plugin for Verilog and SystemVerilog 自己写的一个verilog模块例化自动生成脚本，希望大家能试用，多提bug啊 最后贴一张操作图吧。","categories":[{"name":"editor","slug":"editor","permalink":"https://blog.honk.wang/categories/editor/"}],"tags":[{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"}]},{"title":"hexo&butterfly","slug":"hexo/hexo和butterfly","date":"2019-11-10T07:10:42.000Z","updated":"2020-10-31T11:25:55.595Z","comments":true,"path":"posts/Hexo-Butterfly/","link":"","permalink":"https://blog.honk.wang/posts/Hexo-Butterfly/","excerpt":"","text":"hexo使用 流程 在git bash中跳转到hexo的博客文件夹，输入 12$ hexo new testINFO Created: ~\\desktop\\hexo\\blog\\source\\_posts\\test.md 找到该文章，打开，使用Markdown语法 注意每次generate之前最好清除掉之前的缓存。 1$ hexo clean 编辑完成后，执行以下命令（简写hexo g / hexo s） 1$ hexo generate 123$ hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 打开http://localhost:4000/，文章已经成功发布。 然后发布到github上，执行以下命令（简写hexo d） 1$ hexo deploy 草稿 1$ hexo new (post) 其实是省略了post的写法，会新生成一个post页面。 如果暂时不想发布，只想作为草稿编辑的话，应使用 1$ hexo new draft XXX 通过以下命令查看带草稿页面的hexo预览。 1$ hexo server --draft 通过以下命令将草稿页面publish到正式的post文件中，并自动添加发布时间。 1$ hexo pubulish XXX newXXX butterfly使用 butterfly v3.0.0 地址迁移至Butterfly - A Simple and Card UI Design theme for Hexo。 以下内容均转自Butterfly - A Simple and Card UI Design theme for Hexo，小弋の生活馆全样式预览 | 小弋の生活馆以及 Hexo博客之butterfly主题优雅魔改系列（持续更新） | 小康博客，相关内容可自行去各位大佬博客查询。 渐变色 直接生成即可。彩色渐变字HTML代码生成器 渐变色文字 标签外挂(note) 主题自带note 主题自带的标签。 default 提示塊標籤 primary 提示塊標籤 success 提示塊標籤 info 提示塊標籤 warning 提示塊標籤 danger 提示塊標籤 另一种note 实现起来也很简单，只是对简单的 p 标签进行修改，为了方便添加颜色，这里提供了以上五种配色的样式。 使用起来也会简单，为了兼容各种平台，不推荐 tag 标签的写法。因此只又 html 标签的写法。这样做的好处是即便复制到各大平台也不会出现奇奇怪怪的标签符号或者报错。 note 效果展示： 绿色 红色 黄色 灰色 蓝色 小 tag 标签效果展示： 红色小标签 绿色小标签 蓝色小标签 黄色小标签 灰色小标签 渐变note（上标式外挂标签） 因为标签外挂的语法会导致复制到其他平台不便利，因此建议使用 HTML 写法。 默认情况 success error warning 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 为简单的一句话提供的简便写法。 动画标签 各种标签也可以用html的方式配合上动画，变成动画标签，效果还是比较夸张的！！！ 默认情况 success error warning volantis 主题的 note 因为标签外挂的语法会导致复制到其他平台不便利，因此只提供 HTML 写法。 默认 red info done success danger error radiation bug idea-yellow link- blue paperclip todo msg cyan guide download up undo 小标题Windows 10不是为所有人设计,而是为每个人设计嵌套测试 请坐和放宽，我正在帮你搞定一切… 隐藏按钮(tag-hide ) 主题自带的隐藏按钮。 inline 哪個英文字母最酷？ 查看答案 因為西裝褲(C裝酷) 門裏站着一個人? Click 閃 block 查看答案 傻子，怎麼可能有答案 toggle Butterfly安裝方法 在你的博客根目錄裏 git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 如果想要安裝比較新的dev分支，可以 git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/Butterfly 标签 简单的： test1 3 1test1 3 2test1 3 3This is Tab 1.This is Tab 2.This is Tab 3. 带图标的： 第一個Tab炸彈tab名字為第一個Tab只有圖標 沒有Tab名字名字+icon 复选框 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 + 默认选中 黄色 + 默认选中 青色 + 默认选中 蓝色 + 默认选中 增加 减少 叉 纯文本测试 支持简单的 markdown 语法 支持自定义颜色 绿色 黄色 青色 蓝色 按钮 文内按钮 This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC This is my website, click the button JerryC 独占一行的按钮 JerryC JerryC JerryC 一行多个实心按钮 JerryC JerryC JerryC JerryC JerryC JerryC JerryC 一行多个空心按钮 JerryC JerryC JerryC JerryC JerryC JerryC JerryC 动画图标 起源于看到Sakura主题的Font Awesome动态图标很好看，例如主页图标，研究了一下，原来是一个开源的css代码，只要引入即可！ 自动动画 hover动画","categories":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"butterfly","slug":"butterfly","permalink":"https://blog.honk.wang/tags/butterfly/"}]}],"categories":[{"name":"tools","slug":"tools","permalink":"https://blog.honk.wang/categories/tools/"},{"name":"editor","slug":"editor","permalink":"https://blog.honk.wang/categories/editor/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/categories/hexo/"},{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/categories/ic/"},{"name":"math","slug":"ic/math","permalink":"https://blog.honk.wang/categories/ic/math/"},{"name":"design","slug":"ic/design","permalink":"https://blog.honk.wang/categories/ic/design/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://blog.honk.wang/tags/windows/"},{"name":"software","slug":"software","permalink":"https://blog.honk.wang/tags/software/"},{"name":"gvim","slug":"gvim","permalink":"https://blog.honk.wang/tags/gvim/"},{"name":"vim","slug":"vim","permalink":"https://blog.honk.wang/tags/vim/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.honk.wang/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"https://blog.honk.wang/tags/blog/"},{"name":"verilog","slug":"verilog","permalink":"https://blog.honk.wang/tags/verilog/"},{"name":"cordic","slug":"cordic","permalink":"https://blog.honk.wang/tags/cordic/"},{"name":"ic","slug":"ic","permalink":"https://blog.honk.wang/tags/ic/"},{"name":"cdc","slug":"cdc","permalink":"https://blog.honk.wang/tags/cdc/"},{"name":"butterfly","slug":"butterfly","permalink":"https://blog.honk.wang/tags/butterfly/"}]}